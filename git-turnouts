#!/bin/bash

# Git Turnouts - Your Git branch switching yard
# Manage Git worktrees with intelligent GitHub Pull Request integration

set -e

VERSION="1.0.0"

# ============================================================================
# SHARED HELPER FUNCTIONS
# ============================================================================

# Function to get PR branch by title (exact or partial match)
get_pr_branch_by_title() {
  local search_term="$1"
  local exact_match="$2"

  if [ "$exact_match" = "true" ]; then
    # Exact match - PR title must exactly match the search term
    gh pr list --json number,title,headRefName | \
      jq -r --arg term "$search_term" '.[] | select(.title == $term) | .headRefName' | \
      head -n1
  else
    # Partial match - PR title must contain the search term
    gh pr list --json number,title,headRefName | \
      jq -r --arg term "$search_term" '.[] | select(.title | contains($term)) | .headRefName' | \
      head -n1
  fi
}

# Function to get PR details by PR number
get_pr_details_by_number() {
  local pr_number="$1"

  # Get PR details including state and merge information
  gh pr view "$pr_number" --json headRefName,state,mergedAt,baseRefName 2>/dev/null
}

# Function to get PR branch by PR number
get_pr_branch_by_number() {
  local pr_number="$1"

  # Get PR details by number
  gh pr view "$pr_number" --json headRefName 2>/dev/null | \
    jq -r '.headRefName' 2>/dev/null
}

# Function to check if a string is a PR number (all digits)
is_pr_number() {
  local input="$1"
  [[ "$input" =~ ^[0-9]+$ ]]
}

# Function to check if a string is quoted and strip quotes
check_and_strip_quotes() {
  local input="$1"
  # Check if string starts with " or ' and ends with the same quote
  if [[ "$input" =~ ^\"(.*)\"$ ]] || [[ "$input" =~ ^\'(.*)\'$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0  # Was quoted
  else
    echo "$input"
    return 1  # Was not quoted
  fi
}

# Get the main worktree path
get_main_worktree() {
  git worktree list | head -n1 | awk '{print $1}'
}

# Get project name from main repository
get_project_name() {
  local main_worktree=$(get_main_worktree)
  basename "$main_worktree"
}

# Get base worktree directory
get_base_worktree_dir() {
  local main_worktree=$(get_main_worktree)
  echo "$(dirname "$main_worktree")/worktree"
}

# ============================================================================
# ADD COMMAND - Create new worktrees
# ============================================================================

cmd_add() {
  # Default app to open
  local OPEN_APP="idea"

  # Function to show usage for add command
  show_add_usage() {
    echo "Usage: git-turnouts add <name> [branch-name] [--open <app>]"
    echo ""
    echo "Arguments:"
    echo "  <name>: Folder name for the worktree, PR number, or PR title"
    echo "          If numeric (e.g., 7113), treats as PR number and checkouts that PR"
    echo "          If no branch-name provided, also used as branch name"
    echo "          Will check if this matches any PR title and use that PR's branch"
    echo "  [branch-name]: Optional, specific branch name (defaults to <name>)"
    echo "                 Will check if this matches any PR title and use that PR's branch"
    echo "  --open <app>: Optional, specify where to open (default: idea)"
    echo "                Available apps: idea, code, iterm, warp, finder"
    echo ""
    echo "PR Detection:"
    echo "  - PR Number: If <name> is numeric (e.g., 7113), directly checkouts that PR"
    echo "    Uses PR number as folder name and PR's branch for checkout"
    echo "  - When only <name> is provided: checks if any PR title contains <name>"
    echo "    If found, uses PR's branch name for both folder and branch"
    echo "  - When both arguments provided: checks if any PR title contains [branch-name]"
    echo "    If found, uses PR's branch but keeps specified folder name"
    echo "  - Use quotes for exact title matching: \"exact title\" vs partial matching"
    echo "  - If no matching PR is found, uses standard branch resolution"
    echo ""
    echo "Examples:"
    echo "  git-turnouts add 7113                         # Checkouts PR #7113"
    echo "  git-turnouts add feature-x                    # Creates feature-x worktree"
    echo "  git-turnouts add JIRA-123                     # Checks for PR with JIRA-123"
    echo "  git-turnouts add \"Exact PR Title\"             # Exact title match"
    echo "  git-turnouts add folder-name branch-name      # Different names"
    echo "  git-turnouts add feature-x --open code        # Opens in VS Code"
  }

  if [ -z "$1" ]; then
    show_add_usage
    exit 1
  fi

  # Parse arguments
  local FOLDER_NAME=""
  local BRANCH=""
  local PARSING_OPEN=false
  local EXTRA_ARGS=0

  for arg in "$@"; do
    if [ "$PARSING_OPEN" = true ]; then
      OPEN_APP="$arg"
      PARSING_OPEN=false
    elif [ "$arg" = "--open" ] || [ "$arg" = "-o" ]; then
      PARSING_OPEN=true
    elif [ -z "$FOLDER_NAME" ]; then
      FOLDER_NAME="$arg"
    elif [ -z "$BRANCH" ]; then
      BRANCH="$arg"
    else
      EXTRA_ARGS=$((EXTRA_ARGS + 1))
    fi
  done

  # Validate argument count
  if [ $EXTRA_ARGS -gt 0 ]; then
    echo "‚ùå Error: Too many arguments provided"
    echo "Expected: git-turnouts add <name> [branch-name] [--open <app>]"
    echo ""
    echo "You provided more than 2 positional arguments."
    echo "If your argument contains spaces, please enclose it in quotes."
    echo "Example: git-turnouts add \"My PR Title with spaces\""
    echo ""
    show_add_usage
    exit 1
  fi

  # If no branch specified, use folder name
  if [ -z "$BRANCH" ]; then
    BRANCH="$FOLDER_NAME"
  fi

  # Check if we should use a PR branch
  local PR_BRANCH=""
  local ORIGINAL_FOLDER_NAME="$FOLDER_NAME"

  if [ -z "$BRANCH" ] || [ "$BRANCH" = "$FOLDER_NAME" ]; then
    # Case 1: Only <name> argument passed

    # First check if it's a PR number
    if is_pr_number "$FOLDER_NAME"; then
      echo "üî¢ Detected PR number: #$FOLDER_NAME"
      echo "üîç Fetching PR #$FOLDER_NAME details..."

      # Get full PR details including state
      PR_DETAILS=$(get_pr_details_by_number "$FOLDER_NAME")
      if [ -z "$PR_DETAILS" ]; then
        echo "‚ùå Error: PR #$FOLDER_NAME not found or not accessible"
        exit 1
      fi

      PR_STATE=$(echo "$PR_DETAILS" | jq -r '.state')
      PR_BRANCH=$(echo "$PR_DETAILS" | jq -r '.headRefName')
      BASE_BRANCH=$(echo "$PR_DETAILS" | jq -r '.baseRefName')

      if [ "$PR_STATE" = "MERGED" ]; then
        echo "‚ö†Ô∏è  PR #$FOLDER_NAME has been merged into $BASE_BRANCH"
        echo ""
        echo "The PR branch '$PR_BRANCH' may have been deleted from remote."
        echo ""
        echo "Options:"
        echo "  1. Checkout the merge commit from $BASE_BRANCH"
        echo "  2. If the branch still exists remotely, you can try: git fetch origin $PR_BRANCH"
        echo "  3. Create a new feature branch from $BASE_BRANCH"
        exit 1
      elif [ "$PR_STATE" = "CLOSED" ]; then
        echo "‚ö†Ô∏è  PR #$FOLDER_NAME is closed (not merged)"
        echo "Branch: $PR_BRANCH"
        echo ""
        echo "Note: The branch may still exist. Proceeding to attempt checkout..."
        BRANCH="$PR_BRANCH"
      else
        echo "üìã Found PR #$FOLDER_NAME (state: $PR_STATE), using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      fi
    else
      # Not a PR number, check for PR title matching
      set +e  # Temporarily disable exit on error
      SEARCH_TERM=$(check_and_strip_quotes "$FOLDER_NAME")
      WAS_QUOTED=$?
      set -e  # Re-enable exit on error

      if [ $WAS_QUOTED -eq 0 ]; then
        echo "üîç Checking for PR with exact title '$SEARCH_TERM'..."
        PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "true")
        if [ -n "$PR_BRANCH" ]; then
          echo "üìã Found PR with exact title '$SEARCH_TERM', using branch: $PR_BRANCH"
          BRANCH="$PR_BRANCH"
          FOLDER_NAME="${PR_BRANCH//\//-}"
        else
          echo "‚ÑπÔ∏è  No PR found with exact title '$SEARCH_TERM', using standard branch resolution"
          FOLDER_NAME="$SEARCH_TERM"
        fi
      else
        echo "üîç Checking for PR with title containing '$SEARCH_TERM'..."
        PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "false")
        if [ -n "$PR_BRANCH" ]; then
          echo "üìã Found PR with title containing '$SEARCH_TERM', using branch: $PR_BRANCH"
          BRANCH="$PR_BRANCH"
          FOLDER_NAME="${PR_BRANCH//\//-}"
        else
          echo "‚ÑπÔ∏è  No PR found with title containing '$SEARCH_TERM', using standard branch resolution"
          FOLDER_NAME="$SEARCH_TERM"
        fi
      fi
    fi
  else
    # Case 2: Both <name> and [branch-name] passed
    set +e  # Temporarily disable exit on error
    SEARCH_TERM=$(check_and_strip_quotes "$BRANCH")
    WAS_QUOTED=$?
    set -e  # Re-enable exit on error

    if [ $WAS_QUOTED -eq 0 ]; then
      echo "üîç Checking for PR with exact title '$SEARCH_TERM'..."
      PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "true")
      if [ -n "$PR_BRANCH" ]; then
        echo "üìã Found PR with exact title '$SEARCH_TERM', using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      else
        echo "‚ÑπÔ∏è  No PR found with exact title '$SEARCH_TERM', using standard branch resolution"
        BRANCH="$SEARCH_TERM"
      fi
    else
      echo "üîç Checking for PR with title containing '$SEARCH_TERM'..."
      PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "false")
      if [ -n "$PR_BRANCH" ]; then
        echo "üìã Found PR with title containing '$SEARCH_TERM', using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      else
        echo "‚ÑπÔ∏è  No PR found with title containing '$SEARCH_TERM', using standard branch resolution"
      fi
    fi
  fi

  # Validate open app option
  case "$OPEN_APP" in
    idea|code|iterm|warp|finder)
      ;;
    *)
      echo "‚ùå Error: Invalid app '$OPEN_APP'"
      echo "Valid options: idea, code, iterm, warp, finder"
      exit 1
      ;;
  esac

  # Get the main worktree path
  local MAIN_WORKTREE=$(get_main_worktree)
  local PROJECT_NAME=$(get_project_name)
  local BASE_WORKTREE_DIR=$(get_base_worktree_dir)

  mkdir -p "$BASE_WORKTREE_DIR"

  # Get absolute path of base dir
  local BASE_WORKTREE_DIR_ABS=$(realpath "$BASE_WORKTREE_DIR")

  # Create project-specific directory
  local PROJECT_WORKTREE_DIR="$BASE_WORKTREE_DIR_ABS/$PROJECT_NAME"
  mkdir -p "$PROJECT_WORKTREE_DIR"

  # Append folder name
  local TARGET_DIR="$PROJECT_WORKTREE_DIR/$FOLDER_NAME"

  echo "üì¶ Project: $PROJECT_NAME"
  echo "üìÅ Worktree folder: $TARGET_DIR"
  echo "üåø Branch: $BRANCH"

  # Check if target directory already exists
  if [ -d "$TARGET_DIR" ]; then
    echo "‚ùå Error: Directory already exists: $TARGET_DIR"
    echo "Please choose a different folder name or remove the existing directory first."
    exit 1
  fi

  # Check if branch is already checked out in another worktree
  local EXISTING_WORKTREE=$(git worktree list --porcelain | grep -B2 "branch refs/heads/$BRANCH" | grep "^worktree" | cut -d' ' -f2)
  if [ -n "$EXISTING_WORKTREE" ] && [ "$EXISTING_WORKTREE" != "$TARGET_DIR" ]; then
    echo "‚ùå Error: Branch '$BRANCH' is already checked out in worktree at: $EXISTING_WORKTREE"
    echo ""
    echo "Options:"
    echo "  1. Use a different folder name to create a new branch"
    echo "  2. Navigate to the existing worktree: cd $EXISTING_WORKTREE"
    echo "  3. Remove the existing worktree: git-turnouts remove $BRANCH"
    exit 1
  fi

  # Check if this was a PR number checkout
  local IS_PR_CHECKOUT=false
  if is_pr_number "$ORIGINAL_FOLDER_NAME" && [ -z "$2" ]; then
    IS_PR_CHECKOUT=true
  fi

  # Create worktree based on branch state
  if [ "$IS_PR_CHECKOUT" = true ]; then
    # For PR checkouts, ensure the PR branch is properly fetched
    echo "üîÑ Fetching PR #$ORIGINAL_FOLDER_NAME branch..."

    git fetch origin "$BRANCH" || {
      echo "‚ùå Error: Failed to fetch PR #$ORIGINAL_FOLDER_NAME branch"
      exit 1
    }

    echo "üì¶ Creating worktree for PR #$ORIGINAL_FOLDER_NAME (branch: $BRANCH)"
    git worktree add -B "$BRANCH" "$TARGET_DIR" "origin/$BRANCH"
  elif git show-ref --verify --quiet refs/remotes/origin/$BRANCH; then
    # Remote branch exists, create local branch tracking it
    echo "üöÄ Creating new local branch '$BRANCH' from 'origin/$BRANCH'"
    git worktree add -B "$BRANCH" "$TARGET_DIR" "origin/$BRANCH"
  else
    # No remote branch, create new branch from HEAD
    echo "üÜï Creating new branch '$BRANCH' from HEAD"
    git worktree add -b "$BRANCH" "$TARGET_DIR" HEAD
  fi

  echo "‚úÖ Worktree created at: $TARGET_DIR (branch: $BRANCH)"

  # Open in specified application
  case "$OPEN_APP" in
    idea)
      echo "üß† Opening in IntelliJ IDEA..."
      idea "$TARGET_DIR"
      ;;
    code)
      echo "üìù Opening in VS Code..."
      code "$TARGET_DIR"
      ;;
    iterm)
      echo "üñ•Ô∏è  Opening in iTerm..."
      osascript -e "tell application \"iTerm\"
        create window with default profile
        tell current session of current window
          write text \"cd \\\"$TARGET_DIR\\\"\"
        end tell
      end tell"
      ;;
    warp)
      echo "üöÄ Opening in Warp..."
      open -a Warp "$TARGET_DIR"
      ;;
    finder)
      echo "üìÇ Opening in Finder..."
      open "$TARGET_DIR"
      ;;
  esac
}

# ============================================================================
# REMOVE COMMAND - Remove worktrees
# ============================================================================

cmd_remove() {
  show_remove_usage() {
    echo "Usage: git-turnouts remove <worktree-name> [worktree-name2 ...]"
    echo "       git-turnouts rm <worktree-name> [worktree-name2 ...]"
    echo ""
    echo "Remove one or more worktrees by their branch name."
    echo ""
    echo "Examples:"
    echo "  git-turnouts remove feature-branch"
    echo "  git-turnouts rm test1 test2 feature-branch"
  }

  if [ $# -eq 0 ]; then
    show_remove_usage
    exit 1
  fi

  # Function to remove a single worktree
  remove_worktree() {
    local WORKTREE_NAME="$1"

    # Get all worktrees and find the one matching the given name
    local WORKTREE_PATH=""
    local BRANCH_NAME=""
    while IFS= read -r line; do
      # Extract the branch name from brackets
      if [[ "$line" =~ \[([^\]]+)\] ]]; then
        local BRANCH="${BASH_REMATCH[1]}"
        if [ "$BRANCH" = "$WORKTREE_NAME" ]; then
          # Extract the path (first whitespace-separated token)
          WORKTREE_PATH=$(echo "$line" | awk '{print $1}')
          BRANCH_NAME="$BRANCH"
          break
        fi
      fi
    done < <(git worktree list)

    if [ -z "$WORKTREE_PATH" ]; then
      echo "‚ö†Ô∏è  Warning: No worktree found with name '$WORKTREE_NAME' - skipping"
      return 1
    fi

    echo "Found worktree '$WORKTREE_NAME' at: $WORKTREE_PATH"

    if [ ! -d "$WORKTREE_PATH" ]; then
      echo "‚ö†Ô∏è  Warning: Worktree path '$WORKTREE_PATH' does not exist - skipping"
      return 1
    fi

    echo "Removing worktree '$WORKTREE_NAME' at: $WORKTREE_PATH"

    # Check if this is the main branch to avoid deleting it
    local DEFAULT_BRANCH
    DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    local SKIP_BRANCH_DELETE=false
    if [ "$BRANCH_NAME" = "$DEFAULT_BRANCH" ] || [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
      echo "‚ö†Ô∏è  Warning: Cannot delete protected branch '$BRANCH_NAME' - removing worktree only"
      SKIP_BRANCH_DELETE=true
    fi

    if git worktree remove --force "$WORKTREE_PATH"; then
      echo "‚úÖ Worktree '$WORKTREE_NAME' removed successfully"

      # Now remove the branch if it's safe to do so
      if [ "$SKIP_BRANCH_DELETE" = false ]; then
        echo "üóëÔ∏è  Deleting branch '$BRANCH_NAME'..."
        if git branch -D "$BRANCH_NAME" 2>/dev/null; then
          echo "‚úÖ Branch '$BRANCH_NAME' deleted successfully"
        else
          echo "‚ö†Ô∏è  Warning: Could not delete branch '$BRANCH_NAME' (it may not exist locally or be already deleted)"
        fi
      fi

      return 0
    else
      echo "‚ùå Failed to remove worktree '$WORKTREE_NAME'"
      return 1
    fi
  }

  # Track success/failure
  local TOTAL=0
  local REMOVED=0
  local FAILED=0

  # Show appropriate message based on number of worktrees
  if [ $# -eq 1 ]; then
    echo "üóëÔ∏è  Removing worktree '$1'..."
  else
    echo "üóëÔ∏è  Starting bulk worktree removal..."
  fi
  echo

  # Process each worktree name
  for WORKTREE_NAME in "$@"; do
    TOTAL=$((TOTAL + 1))

    # Show progress counter only for multiple worktrees
    if [ $# -gt 1 ]; then
      echo "[$TOTAL/$#] Processing '$WORKTREE_NAME'..."
    fi

    if remove_worktree "$WORKTREE_NAME"; then
      REMOVED=$((REMOVED + 1))
    else
      FAILED=$((FAILED + 1))
    fi

    echo
  done

  # Prune once at the end
  echo "Pruning stale worktree references..."
  git worktree prune

  # Summary
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "üìä Summary:"
  echo "   Total: $TOTAL"
  echo "   ‚úÖ Removed: $REMOVED"
  if [ $FAILED -gt 0 ]; then
    echo "   ‚ö†Ô∏è  Failed/Skipped: $FAILED"
  fi
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # Show updated list
  echo
  echo "üìã Updated list of worktrees:"
  git worktree list

  # Exit with error if all removals failed
  if [ $REMOVED -eq 0 ] && [ $TOTAL -gt 0 ]; then
    exit 1
  fi
}

# ============================================================================
# LIST COMMAND - List all worktrees
# ============================================================================

cmd_list() {
  echo "üìã Git Worktrees:"
  git worktree list
}

# ============================================================================
# HELP & VERSION
# ============================================================================

show_help() {
  cat << EOF
Git Turnouts v${VERSION} - Your Git branch switching yard

Manage Git worktrees with intelligent GitHub Pull Request integration.
Just like railroad turnouts route trains between tracks, Git Turnouts helps
you seamlessly switch between multiple branches and work contexts.

USAGE:
    git-turnouts <command> [options]

COMMANDS:
    add <name> [branch] [--open <app>]
        Create a new worktree with optional PR integration

    remove <name> [name2 ...]
    rm <name> [name2 ...]
        Remove one or more worktrees

    list
    ls
        List all worktrees

    help
    --help
    -h
        Show this help message

    version
    --version
    -v
        Show version information

EXAMPLES:
    # Create worktree from PR number
    git-turnouts add 7113

    # Create worktree and open in VS Code
    git-turnouts add feature-x --open code

    # Search for PR by title
    git-turnouts add "Add authentication"

    # Remove worktrees
    git-turnouts remove feature-x
    git-turnouts rm feat-1 feat-2 feat-3

    # List all worktrees
    git-turnouts list

For more information, visit:
https://github.com/yourusername/git-turnouts

EOF
}

show_version() {
  echo "Git Turnouts v${VERSION}"
}

# ============================================================================
# MAIN DISPATCHER
# ============================================================================

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "‚ùå Error: Not a git repository"
  exit 1
fi

# Parse command
COMMAND="${1:-help}"
shift || true

case "$COMMAND" in
  add)
    cmd_add "$@"
    ;;
  remove|rm)
    cmd_remove "$@"
    ;;
  list|ls)
    cmd_list "$@"
    ;;
  help|--help|-h)
    show_help
    ;;
  version|--version|-v)
    show_version
    ;;
  *)
    echo "‚ùå Error: Unknown command '$COMMAND'"
    echo ""
    echo "Run 'git-turnouts help' for usage information"
    exit 1
    ;;
esac
