#!/bin/bash

# Git Turnouts - Your Git branch switching yard
# Manage Git worktrees with intelligent GitHub Pull Request integration

set -e

VERSION="1.0.0"

# ============================================================================
# SHARED HELPER FUNCTIONS
# ============================================================================

# Function to get PR branch by title (exact or partial match)
get_pr_branch_by_title() {
  local search_term="$1"
  local exact_match="$2"

  if [ "$exact_match" = "true" ]; then
    # Exact match - PR title must exactly match the search term
    gh pr list --json number,title,headRefName | \
      jq -r --arg term "$search_term" '.[] | select(.title == $term) | .headRefName' | \
      head -n1
  else
    # Partial match - PR title must contain the search term
    gh pr list --json number,title,headRefName | \
      jq -r --arg term "$search_term" '.[] | select(.title | contains($term)) | .headRefName' | \
      head -n1
  fi
}

# Function to get PR details by PR number
get_pr_details_by_number() {
  local pr_number="$1"

  # Get PR details including state and merge information
  gh pr view "$pr_number" --json headRefName,state,mergedAt,baseRefName 2>/dev/null
}

# Function to get PR branch by PR number
get_pr_branch_by_number() {
  local pr_number="$1"

  # Get PR details by number
  gh pr view "$pr_number" --json headRefName 2>/dev/null | \
    jq -r '.headRefName' 2>/dev/null
}

# Function to check if a string is a PR number (all digits)
is_pr_number() {
  local input="$1"
  [[ "$input" =~ ^[0-9]+$ ]]
}

# Function to check if a string is quoted and strip quotes
check_and_strip_quotes() {
  local input="$1"
  # Check if string starts with " or ' and ends with the same quote
  if [[ "$input" =~ ^\"(.*)\"$ ]] || [[ "$input" =~ ^\'(.*)\'$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0  # Was quoted
  else
    echo "$input"
    return 1  # Was not quoted
  fi
}

# Get the main worktree path
get_main_worktree() {
  git worktree list | head -n1 | awk '{print $1}'
}

# Get project name from main repository
get_project_name() {
  local main_worktree=$(get_main_worktree)
  basename "$main_worktree"
}

# Get base worktree directory
# Returns the base directory where worktrees should be created
# The project name will be automatically added as a subdirectory
get_base_worktree_dir() {
  local project_name=$(get_project_name)

  # 1. Check for project-specific configuration
  local project_base=$(get_config "worktree.projects.${project_name}.base_dir" "")
  if [ -n "$project_base" ]; then
    echo "$project_base"
    return
  fi

  # 2. Check for global configuration
  local global_base=$(get_config "worktree.global.base_dir" "")
  if [ -n "$global_base" ]; then
    echo "$global_base"
    return
  fi

  # 3. Fallback to automatic detection (current behavior)
  local main_worktree=$(get_main_worktree)
  echo "$(dirname "$main_worktree")/worktree"
}

# ============================================================================
# CONFIGURATION SYSTEM
# ============================================================================

# Configuration variables (bash 3.2 compatible - no associative arrays)
CONFIG_WORKTREE_GLOBAL_BASE_DIR=""       # Global base directory (project name added automatically)
CONFIG_WORKTREE_PROJECTS=""              # Space-separated list: "project1:path1 project2:path2"
CONFIG_DEFAULTS_OPEN_WITH="idea"
CONFIG_REMOVE_AUTO_PRUNE="true"
CONFIG_COPY_FILES=""                     # Space-separated list
CONFIG_PROTECTED_BRANCHES="main master"  # Space-separated list

# Parse simple YAML configuration (bash 3.2 compatible)
# Supports: nested keys up to 3 levels and lists
parse_yaml_config() {
  local config_file="$1"
  local section=""      # Level 1: worktree, defaults, etc.
  local subsection=""   # Level 2: global, projects, copy_files, etc.
  local list_key=""
  local in_list=false
  local in_project_item=false
  local current_project_name=""
  local current_project_base=""

  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// /}" ]] && continue

    # Level 1: Section headers (e.g., "worktree:")
    if [[ "$line" =~ ^([a-z_]+):([[:space:]]*|[[:space:]]+.*)$ ]]; then
      section="${BASH_REMATCH[1]}"
      subsection=""
      in_list=false
      in_project_item=false
      continue
    fi

    # Level 2: Subsection headers (e.g., "  global:" or "  projects:")
    if [[ "$line" =~ ^[[:space:]]{2}([a-z_]+):[[:space:]]*(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      if [ -z "$value" ]; then
        # Save current project before transitioning to new subsection
        if [ "$in_project_item" = true ] && [ -n "$current_project_name" ] && [ -n "$current_project_base" ]; then
          CONFIG_WORKTREE_PROJECTS="$CONFIG_WORKTREE_PROJECTS ${current_project_name}:${current_project_base}"
        fi

        # It's a subsection header
        subsection="$key"
        in_list=false
        in_project_item=false
      else
        # It's a key-value pair at level 2
        # Expand tilde in paths
        if [[ "$value" == ~* ]]; then
          value="${value/#\~/$HOME}"
        fi

        # Handle level 2 keys
        case "${section}.${key}" in
          "defaults.open_with")
            CONFIG_DEFAULTS_OPEN_WITH="$value"
            ;;
          "remove.auto_prune")
            CONFIG_REMOVE_AUTO_PRUNE="$value"
            ;;
        esac
        in_list=false
        in_project_item=false
      fi
      continue
    fi

    # Level 3: Handle "- " for list items under projects
    if [[ "$line" =~ ^[[:space:]]{4}-[[:space:]]*(.*)$ ]]; then
      # Save previous project if we were parsing one
      if [ "$in_project_item" = true ] && [ -n "$current_project_name" ] && [ -n "$current_project_base" ]; then
        CONFIG_WORKTREE_PROJECTS="$CONFIG_WORKTREE_PROJECTS ${current_project_name}:${current_project_base}"
      fi

      # Start new project item
      if [ "$section" = "worktree" ] && [ "$subsection" = "projects" ]; then
        in_project_item=true
        current_project_name=""
        current_project_base=""

        # Check if name: is on the same line as dash
        local rest="${BASH_REMATCH[1]}"
        if [[ "$rest" =~ ^name:[[:space:]]*(.+)$ ]]; then
          current_project_name="${BASH_REMATCH[1]}"
        fi
      else
        # Regular list item (for copy_files, protected_branches, etc.)
        local item="${BASH_REMATCH[1]}"
        if [ "$subsection" = "copy_files" ]; then
          CONFIG_COPY_FILES="$CONFIG_COPY_FILES $item"
        elif [ "$section" = "protection" ] && [ "$subsection" = "protected_branches" ]; then
          CONFIG_PROTECTED_BRANCHES="$CONFIG_PROTECTED_BRANCHES $item"
        fi
        in_project_item=false
      fi
      continue
    fi

    # Level 3: Nested keys under subsections (e.g., "    base_dir: value")
    if [[ "$line" =~ ^[[:space:]]{4}([a-z_]+):[[:space:]]*(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Expand tilde in paths
      if [[ "$value" == ~* ]]; then
        value="${value/#\~/$HOME}"
      fi

      # Handle keys under global
      if [ "$section" = "worktree" ] && [ "$subsection" = "global" ] && [ "$key" = "base_dir" ]; then
        CONFIG_WORKTREE_GLOBAL_BASE_DIR="$value"
      fi

      # Handle keys under protection
      if [ "$section" = "protection" ] && [ "$key" = "protected_branches" ] && [ -z "$value" ]; then
        in_list=true
        subsection="protected_branches"
      fi

      # Handle keys under worktree for copy_files
      if [ "$section" = "worktree" ] && [ "$key" = "copy_files" ] && [ -z "$value" ]; then
        in_list=true
        subsection="copy_files"
      fi

      in_project_item=false
      continue
    fi

    # Level 4: Properties within project list items (e.g., "      name: value" or "      base_dir: value")
    if [[ "$line" =~ ^[[:space:]]{6}([a-z_]+):[[:space:]]*(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Expand tilde in paths
      if [[ "$value" == ~* ]]; then
        value="${value/#\~/$HOME}"
      fi

      # Handle project properties
      if [ "$in_project_item" = true ]; then
        if [ "$key" = "name" ]; then
          current_project_name="$value"
        elif [ "$key" = "base_dir" ]; then
          current_project_base="$value"
        fi
      fi
      continue
    fi
  done < "$config_file"

  # Save last project if we were parsing one
  if [ "$in_project_item" = true ] && [ -n "$current_project_name" ] && [ -n "$current_project_base" ]; then
    CONFIG_WORKTREE_PROJECTS="$CONFIG_WORKTREE_PROJECTS ${current_project_name}:${current_project_base}"
  fi

  # Trim leading spaces from lists
  CONFIG_COPY_FILES="${CONFIG_COPY_FILES## }"
  CONFIG_PROTECTED_BRANCHES="${CONFIG_PROTECTED_BRANCHES## }"
  CONFIG_WORKTREE_PROJECTS="${CONFIG_WORKTREE_PROJECTS## }"
}

# Validate configuration values (bash 3.2 compatible)
validate_configuration() {
  # Validate defaults.open_with
  if [ -n "$CONFIG_DEFAULTS_OPEN_WITH" ]; then
    case "$CONFIG_DEFAULTS_OPEN_WITH" in
      idea|code|iterm|warp|finder)
        ;;  # Valid
      *)
        echo "‚ö†Ô∏è  Warning: Invalid defaults.open_with value '$CONFIG_DEFAULTS_OPEN_WITH' in config"
        echo "   Valid options: idea, code, iterm, warp, finder"
        echo "   Falling back to default: idea"
        CONFIG_DEFAULTS_OPEN_WITH="idea"
        ;;
    esac
  fi

  # Validate worktree.base_dir exists or can be created
  if [ -n "$CONFIG_WORKTREE_BASE_DIR" ]; then
    # Check if directory exists or parent exists
    if [ ! -d "$CONFIG_WORKTREE_BASE_DIR" ]; then
      local parent_dir=$(dirname "$CONFIG_WORKTREE_BASE_DIR")
      if [ ! -d "$parent_dir" ]; then
        echo "‚ö†Ô∏è  Warning: Configured worktree.base_dir parent does not exist: $parent_dir"
        echo "   Falling back to automatic detection"
        CONFIG_WORKTREE_BASE_DIR=""
      fi
    fi
  fi

  # Validate and normalize remove.auto_prune to true/false
  case "$CONFIG_REMOVE_AUTO_PRUNE" in
    true|false)
      ;;  # Already normalized
    yes|1)
      CONFIG_REMOVE_AUTO_PRUNE="true"
      ;;
    no|0)
      CONFIG_REMOVE_AUTO_PRUNE="false"
      ;;
    *)
      echo "‚ö†Ô∏è  Warning: Invalid remove.auto_prune value '$CONFIG_REMOVE_AUTO_PRUNE' in config"
      echo "   Valid options: true, false, yes, no, 1, 0"
      echo "   Falling back to default: true"
      CONFIG_REMOVE_AUTO_PRUNE="true"
      ;;
  esac
}

# Load configuration from file (bash 3.2 compatible)
load_configuration() {
  # Get the directory where git-turnouts is installed
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local config_file="$script_dir/.config.yml"

  # Defaults are already set in variable declarations above
  # Only load and parse if config file exists
  if [ -f "$config_file" ]; then
    if [ -r "$config_file" ]; then
      parse_yaml_config "$config_file" 2>/dev/null || {
        echo "‚ö†Ô∏è  Warning: Error parsing config file: $config_file"
        echo "   Continuing with defaults..."
      }
      # Validate configuration after loading
      validate_configuration
    else
      echo "‚ö†Ô∏è  Warning: Cannot read config file: $config_file"
      echo "   Continuing with defaults..."
    fi
  fi
}

# Get configuration value with fallback (bash 3.2 compatible)
get_config() {
  local key="$1"
  local default="${2:-}"

  case "$key" in
    worktree.global.base_dir)
      if [ -n "$CONFIG_WORKTREE_GLOBAL_BASE_DIR" ]; then
        echo "$CONFIG_WORKTREE_GLOBAL_BASE_DIR"
      else
        echo "$default"
      fi
      ;;
    worktree.projects.*.base_dir)
      # Extract project name from key: worktree.projects.PROJECT_NAME.base_dir
      local project=$(echo "$key" | sed 's/worktree\.projects\.\(.*\)\.base_dir/\1/')

      # Search in CONFIG_WORKTREE_PROJECTS for matching project
      for entry in $CONFIG_WORKTREE_PROJECTS; do
        local proj_name="${entry%%:*}"
        local proj_path="${entry#*:}"
        if [ "$proj_name" = "$project" ]; then
          echo "$proj_path"
          return
        fi
      done
      echo "$default"
      ;;
    defaults.open_with)
      if [ -n "$CONFIG_DEFAULTS_OPEN_WITH" ]; then
        echo "$CONFIG_DEFAULTS_OPEN_WITH"
      else
        echo "$default"
      fi
      ;;
    remove.auto_prune)
      if [ -n "$CONFIG_REMOVE_AUTO_PRUNE" ]; then
        echo "$CONFIG_REMOVE_AUTO_PRUNE"
      else
        echo "$default"
      fi
      ;;
    *)
      echo "$default"
      ;;
  esac
}

# Copy configured files from main worktree to new worktree (bash 3.2 compatible)
copy_configured_files() {
  local source_dir="$1"    # Main worktree path
  local target_dir="$2"    # New worktree path

  # Check if there are files to copy
  if [ -z "$CONFIG_COPY_FILES" ]; then
    return 0
  fi

  echo "üìÑ Copying configured files..."
  local copied=0
  local skipped=0

  # Iterate over space-separated list
  for file in $CONFIG_COPY_FILES; do
    local source_file="$source_dir/$file"
    local target_file="$target_dir/$file"

    if [ -f "$source_file" ]; then
      # Create target directory if needed
      local target_dir_parent=$(dirname "$target_file")
      mkdir -p "$target_dir_parent"

      # Copy file
      if cp "$source_file" "$target_file" 2>/dev/null; then
        echo "   ‚úì Copied: $file"
        copied=$((copied + 1))
      else
        echo "   ‚ö† Failed to copy: $file"
        skipped=$((skipped + 1))
      fi
    else
      echo "   ‚ö† Not found: $file (skipped)"
      skipped=$((skipped + 1))
    fi
  done

  if [ $copied -gt 0 ]; then
    echo "   Copied $copied file(s)"
  fi
  if [ $skipped -gt 0 ]; then
    echo "   Skipped $skipped file(s)"
  fi
}

# ============================================================================
# ADD COMMAND - Create new worktrees
# ============================================================================

cmd_add() {
  # Load default from config
  local OPEN_APP=$(get_config "defaults.open_with" "idea")

  # Function to show usage for add command
  show_add_usage() {
    echo "Usage: git-turnouts add <name> [branch-name] [--open <app>]"
    echo ""
    echo "Arguments:"
    echo "  <name>: Folder name for the worktree, PR number, or PR title"
    echo "          If numeric (e.g., 7113), treats as PR number and checkouts that PR"
    echo "          If no branch-name provided, also used as branch name"
    echo "          Will check if this matches any PR title and use that PR's branch"
    echo "  [branch-name]: Optional, specific branch name (defaults to <name>)"
    echo "                 Will check if this matches any PR title and use that PR's branch"
    echo "  --open <app>: Optional, specify where to open (default: idea)"
    echo "                Available apps: idea, code, iterm, warp, finder"
    echo ""
    echo "PR Detection:"
    echo "  - PR Number: If <name> is numeric (e.g., 7113), directly checkouts that PR"
    echo "    Uses PR number as folder name and PR's branch for checkout"
    echo "  - When only <name> is provided: checks if any PR title contains <name>"
    echo "    If found, uses PR's branch name for both folder and branch"
    echo "  - When both arguments provided: checks if any PR title contains [branch-name]"
    echo "    If found, uses PR's branch but keeps specified folder name"
    echo "  - Use quotes for exact title matching: \"exact title\" vs partial matching"
    echo "  - If no matching PR is found, uses standard branch resolution"
    echo ""
    echo "Examples:"
    echo "  git-turnouts add 7113                         # Checkouts PR #7113"
    echo "  git-turnouts add feature-x                    # Creates feature-x worktree"
    echo "  git-turnouts add JIRA-123                     # Checks for PR with JIRA-123"
    echo "  git-turnouts add \"Exact PR Title\"             # Exact title match"
    echo "  git-turnouts add folder-name branch-name      # Different names"
    echo "  git-turnouts add feature-x --open code        # Opens in VS Code"
  }

  if [ -z "$1" ]; then
    show_add_usage
    exit 1
  fi

  # Parse arguments
  local FOLDER_NAME=""
  local BRANCH=""
  local PARSING_OPEN=false
  local EXTRA_ARGS=0

  for arg in "$@"; do
    if [ "$PARSING_OPEN" = true ]; then
      OPEN_APP="$arg"
      PARSING_OPEN=false
    elif [ "$arg" = "--open" ] || [ "$arg" = "-o" ]; then
      PARSING_OPEN=true
    elif [ -z "$FOLDER_NAME" ]; then
      FOLDER_NAME="$arg"
    elif [ -z "$BRANCH" ]; then
      BRANCH="$arg"
    else
      EXTRA_ARGS=$((EXTRA_ARGS + 1))
    fi
  done

  # Validate argument count
  if [ $EXTRA_ARGS -gt 0 ]; then
    echo "‚ùå Error: Too many arguments provided"
    echo "Expected: git-turnouts add <name> [branch-name] [--open <app>]"
    echo ""
    echo "You provided more than 2 positional arguments."
    echo "If your argument contains spaces, please enclose it in quotes."
    echo "Example: git-turnouts add \"My PR Title with spaces\""
    echo ""
    show_add_usage
    exit 1
  fi

  # If no branch specified, use folder name
  if [ -z "$BRANCH" ]; then
    BRANCH="$FOLDER_NAME"
  fi

  # Check if we should use a PR branch
  local PR_BRANCH=""
  local ORIGINAL_FOLDER_NAME="$FOLDER_NAME"

  if [ -z "$BRANCH" ] || [ "$BRANCH" = "$FOLDER_NAME" ]; then
    # Case 1: Only <name> argument passed

    # First check if it's a PR number
    if is_pr_number "$FOLDER_NAME"; then
      echo "üî¢ Detected PR number: #$FOLDER_NAME"
      echo "üîç Fetching PR #$FOLDER_NAME details..."

      # Get full PR details including state
      PR_DETAILS=$(get_pr_details_by_number "$FOLDER_NAME")
      if [ -z "$PR_DETAILS" ]; then
        echo "‚ùå Error: PR #$FOLDER_NAME not found or not accessible"
        exit 1
      fi

      PR_STATE=$(echo "$PR_DETAILS" | jq -r '.state')
      PR_BRANCH=$(echo "$PR_DETAILS" | jq -r '.headRefName')
      BASE_BRANCH=$(echo "$PR_DETAILS" | jq -r '.baseRefName')

      if [ "$PR_STATE" = "MERGED" ]; then
        echo "‚ö†Ô∏è  PR #$FOLDER_NAME has been merged into $BASE_BRANCH"
        echo ""
        echo "The PR branch '$PR_BRANCH' may have been deleted from remote."
        echo ""
        echo "Options:"
        echo "  1. Checkout the merge commit from $BASE_BRANCH"
        echo "  2. If the branch still exists remotely, you can try: git fetch origin $PR_BRANCH"
        echo "  3. Create a new feature branch from $BASE_BRANCH"
        exit 1
      elif [ "$PR_STATE" = "CLOSED" ]; then
        echo "‚ö†Ô∏è  PR #$FOLDER_NAME is closed (not merged)"
        echo "Branch: $PR_BRANCH"
        echo ""
        echo "Note: The branch may still exist. Proceeding to attempt checkout..."
        BRANCH="$PR_BRANCH"
      else
        echo "üìã Found PR #$FOLDER_NAME (state: $PR_STATE), using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      fi
    else
      # Not a PR number, check for PR title matching
      set +e  # Temporarily disable exit on error
      SEARCH_TERM=$(check_and_strip_quotes "$FOLDER_NAME")
      WAS_QUOTED=$?
      set -e  # Re-enable exit on error

      if [ $WAS_QUOTED -eq 0 ]; then
        echo "üîç Checking for PR with exact title '$SEARCH_TERM'..."
        PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "true")
        if [ -n "$PR_BRANCH" ]; then
          echo "üìã Found PR with exact title '$SEARCH_TERM', using branch: $PR_BRANCH"
          BRANCH="$PR_BRANCH"
          FOLDER_NAME="${PR_BRANCH//\//-}"
        else
          echo "‚ÑπÔ∏è  No PR found with exact title '$SEARCH_TERM', using standard branch resolution"
          FOLDER_NAME="$SEARCH_TERM"
        fi
      else
        echo "üîç Checking for PR with title containing '$SEARCH_TERM'..."
        PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "false")
        if [ -n "$PR_BRANCH" ]; then
          echo "üìã Found PR with title containing '$SEARCH_TERM', using branch: $PR_BRANCH"
          BRANCH="$PR_BRANCH"
          FOLDER_NAME="${PR_BRANCH//\//-}"
        else
          echo "‚ÑπÔ∏è  No PR found with title containing '$SEARCH_TERM', using standard branch resolution"
          FOLDER_NAME="$SEARCH_TERM"
        fi
      fi
    fi
  else
    # Case 2: Both <name> and [branch-name] passed
    set +e  # Temporarily disable exit on error
    SEARCH_TERM=$(check_and_strip_quotes "$BRANCH")
    WAS_QUOTED=$?
    set -e  # Re-enable exit on error

    if [ $WAS_QUOTED -eq 0 ]; then
      echo "üîç Checking for PR with exact title '$SEARCH_TERM'..."
      PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "true")
      if [ -n "$PR_BRANCH" ]; then
        echo "üìã Found PR with exact title '$SEARCH_TERM', using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      else
        echo "‚ÑπÔ∏è  No PR found with exact title '$SEARCH_TERM', using standard branch resolution"
        BRANCH="$SEARCH_TERM"
      fi
    else
      echo "üîç Checking for PR with title containing '$SEARCH_TERM'..."
      PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "false")
      if [ -n "$PR_BRANCH" ]; then
        echo "üìã Found PR with title containing '$SEARCH_TERM', using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      else
        echo "‚ÑπÔ∏è  No PR found with title containing '$SEARCH_TERM', using standard branch resolution"
      fi
    fi
  fi

  # Validate open app option
  case "$OPEN_APP" in
    idea|code|iterm|warp|finder)
      ;;
    *)
      echo "‚ùå Error: Invalid app '$OPEN_APP'"
      echo "Valid options: idea, code, iterm, warp, finder"
      exit 1
      ;;
  esac

  # Get the main worktree path
  local MAIN_WORKTREE=$(get_main_worktree)
  local PROJECT_NAME=$(get_project_name)
  local BASE_WORKTREE_DIR=$(get_base_worktree_dir)

  mkdir -p "$BASE_WORKTREE_DIR"

  # Get absolute path of base dir
  local BASE_WORKTREE_DIR_ABS=$(realpath "$BASE_WORKTREE_DIR")

  # Create project-specific directory (always added for organization)
  local PROJECT_WORKTREE_DIR="$BASE_WORKTREE_DIR_ABS/$PROJECT_NAME"
  mkdir -p "$PROJECT_WORKTREE_DIR"

  # Append folder name
  local TARGET_DIR="$PROJECT_WORKTREE_DIR/$FOLDER_NAME"

  echo "üì¶ Project: $PROJECT_NAME"
  echo "üìÅ Worktree folder: $TARGET_DIR"
  echo "üåø Branch: $BRANCH"

  # Check if target directory already exists
  if [ -d "$TARGET_DIR" ]; then
    echo "‚ùå Error: Directory already exists: $TARGET_DIR"
    echo "Please choose a different folder name or remove the existing directory first."
    exit 1
  fi

  # Check if branch is already checked out in another worktree
  local EXISTING_WORKTREE=$(git worktree list --porcelain | grep -B2 "branch refs/heads/$BRANCH" | grep "^worktree" | cut -d' ' -f2)
  if [ -n "$EXISTING_WORKTREE" ] && [ "$EXISTING_WORKTREE" != "$TARGET_DIR" ]; then
    echo "‚ùå Error: Branch '$BRANCH' is already checked out in worktree at: $EXISTING_WORKTREE"
    echo ""
    echo "Options:"
    echo "  1. Use a different folder name to create a new branch"
    echo "  2. Navigate to the existing worktree: cd $EXISTING_WORKTREE"
    echo "  3. Remove the existing worktree: git-turnouts remove $BRANCH"
    exit 1
  fi

  # Check if this was a PR number checkout
  local IS_PR_CHECKOUT=false
  if is_pr_number "$ORIGINAL_FOLDER_NAME" && [ -z "$2" ]; then
    IS_PR_CHECKOUT=true
  fi

  # Create worktree based on branch state
  if [ "$IS_PR_CHECKOUT" = true ]; then
    # For PR checkouts, ensure the PR branch is properly fetched
    echo "üîÑ Fetching PR #$ORIGINAL_FOLDER_NAME branch..."

    git fetch origin "$BRANCH" || {
      echo "‚ùå Error: Failed to fetch PR #$ORIGINAL_FOLDER_NAME branch"
      exit 1
    }

    echo "üì¶ Creating worktree for PR #$ORIGINAL_FOLDER_NAME (branch: $BRANCH)"
    git worktree add -B "$BRANCH" "$TARGET_DIR" "origin/$BRANCH"
  elif git show-ref --verify --quiet refs/remotes/origin/$BRANCH; then
    # Remote branch exists, create local branch tracking it
    echo "üöÄ Creating new local branch '$BRANCH' from 'origin/$BRANCH'"
    git worktree add -B "$BRANCH" "$TARGET_DIR" "origin/$BRANCH"
  else
    # No remote branch, create new branch from HEAD
    echo "üÜï Creating new branch '$BRANCH' from HEAD"
    git worktree add -b "$BRANCH" "$TARGET_DIR" HEAD
  fi

  echo "‚úÖ Worktree created at: $TARGET_DIR (branch: $BRANCH)"

  # Copy configured files
  copy_configured_files "$MAIN_WORKTREE" "$TARGET_DIR"

  # Open in specified application
  case "$OPEN_APP" in
    idea)
      echo "üß† Opening in IntelliJ IDEA..."
      idea "$TARGET_DIR"
      ;;
    code)
      echo "üìù Opening in VS Code..."
      code "$TARGET_DIR"
      ;;
    iterm)
      echo "üñ•Ô∏è  Opening in iTerm..."
      osascript -e "tell application \"iTerm\"
        create window with default profile
        tell current session of current window
          write text \"cd \\\"$TARGET_DIR\\\"\"
        end tell
      end tell"
      ;;
    warp)
      echo "üöÄ Opening in Warp..."
      open -a Warp "$TARGET_DIR"
      ;;
    finder)
      echo "üìÇ Opening in Finder..."
      open "$TARGET_DIR"
      ;;
  esac
}

# ============================================================================
# REMOVE COMMAND - Remove worktrees
# ============================================================================

cmd_remove() {
  show_remove_usage() {
    echo "Usage: git-turnouts remove <worktree-name> [worktree-name2 ...]"
    echo "       git-turnouts rm <worktree-name> [worktree-name2 ...]"
    echo ""
    echo "Remove one or more worktrees by their branch name."
    echo ""
    echo "Examples:"
    echo "  git-turnouts remove feature-branch"
    echo "  git-turnouts rm test1 test2 feature-branch"
  }

  if [ $# -eq 0 ]; then
    show_remove_usage
    exit 1
  fi

  # Function to remove a single worktree
  remove_worktree() {
    local WORKTREE_NAME="$1"

    # Get all worktrees and find the one matching the given name
    local WORKTREE_PATH=""
    local BRANCH_NAME=""
    while IFS= read -r line; do
      # Extract the branch name from brackets
      if [[ "$line" =~ \[([^\]]+)\] ]]; then
        local BRANCH="${BASH_REMATCH[1]}"
        if [ "$BRANCH" = "$WORKTREE_NAME" ]; then
          # Extract the path (first whitespace-separated token)
          WORKTREE_PATH=$(echo "$line" | awk '{print $1}')
          BRANCH_NAME="$BRANCH"
          break
        fi
      fi
    done < <(git worktree list)

    if [ -z "$WORKTREE_PATH" ]; then
      echo "‚ö†Ô∏è  Warning: No worktree found with name '$WORKTREE_NAME' - skipping"
      return 1
    fi

    echo "Found worktree '$WORKTREE_NAME' at: $WORKTREE_PATH"

    if [ ! -d "$WORKTREE_PATH" ]; then
      echo "‚ö†Ô∏è  Warning: Worktree path '$WORKTREE_PATH' does not exist - skipping"
      return 1
    fi

    echo "Removing worktree '$WORKTREE_NAME' at: $WORKTREE_PATH"

    # Check if this is a protected branch to avoid deleting it
    local DEFAULT_BRANCH
    DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    # Check against configured protected branches (space-separated list)
    local SKIP_BRANCH_DELETE=false
    for protected in $CONFIG_PROTECTED_BRANCHES $DEFAULT_BRANCH; do
      if [ "$BRANCH_NAME" = "$protected" ]; then
        echo "‚ö†Ô∏è  Warning: Cannot delete protected branch '$BRANCH_NAME' - removing worktree only"
        SKIP_BRANCH_DELETE=true
        break
      fi
    done

    if git worktree remove --force "$WORKTREE_PATH"; then
      echo "‚úÖ Worktree '$WORKTREE_NAME' removed successfully"

      # Now remove the branch if it's safe to do so
      if [ "$SKIP_BRANCH_DELETE" = false ]; then
        echo "üóëÔ∏è  Deleting branch '$BRANCH_NAME'..."
        if git branch -D "$BRANCH_NAME" 2>/dev/null; then
          echo "‚úÖ Branch '$BRANCH_NAME' deleted successfully"
        else
          echo "‚ö†Ô∏è  Warning: Could not delete branch '$BRANCH_NAME' (it may not exist locally or be already deleted)"
        fi
      fi

      return 0
    else
      echo "‚ùå Failed to remove worktree '$WORKTREE_NAME'"
      return 1
    fi
  }

  # Track success/failure
  local TOTAL=0
  local REMOVED=0
  local FAILED=0

  # Show appropriate message based on number of worktrees
  if [ $# -eq 1 ]; then
    echo "üóëÔ∏è  Removing worktree '$1'..."
  else
    echo "üóëÔ∏è  Starting bulk worktree removal..."
  fi
  echo

  # Process each worktree name
  for WORKTREE_NAME in "$@"; do
    TOTAL=$((TOTAL + 1))

    # Show progress counter only for multiple worktrees
    if [ $# -gt 1 ]; then
      echo "[$TOTAL/$#] Processing '$WORKTREE_NAME'..."
    fi

    if remove_worktree "$WORKTREE_NAME"; then
      REMOVED=$((REMOVED + 1))
    else
      FAILED=$((FAILED + 1))
    fi

    echo
  done

  # Prune once at the end (if configured)
  local auto_prune=$(get_config "remove.auto_prune" "true")
  if [ "$auto_prune" = "true" ]; then
    echo "Pruning stale worktree references..."
    git worktree prune
  else
    echo "‚ÑπÔ∏è  Skipping prune (disabled in config)"
  fi

  # Summary
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "üìä Summary:"
  echo "   Total: $TOTAL"
  echo "   ‚úÖ Removed: $REMOVED"
  if [ $FAILED -gt 0 ]; then
    echo "   ‚ö†Ô∏è  Failed/Skipped: $FAILED"
  fi
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # Show updated list
  echo
  echo "üìã Updated list of worktrees:"
  git worktree list

  # Exit with error if all removals failed
  if [ $REMOVED -eq 0 ] && [ $TOTAL -gt 0 ]; then
    exit 1
  fi
}

# ============================================================================
# LIST COMMAND - List all worktrees
# ============================================================================

cmd_list() {
  echo "üìã Git Worktrees:"
  git worktree list
}

# ============================================================================
# HELP & VERSION
# ============================================================================

show_help() {
  cat << EOF
Git Turnouts v${VERSION} - Your Git branch switching yard

Manage Git worktrees with intelligent GitHub Pull Request integration.
Just like railroad turnouts route trains between tracks, Git Turnouts helps
you seamlessly switch between multiple branches and work contexts.

USAGE:
    git-turnouts <command> [options]

COMMANDS:
    add <name> [branch] [--open <app>]
        Create a new worktree with optional PR integration

    remove <name> [name2 ...]
    rm <name> [name2 ...]
        Remove one or more worktrees

    list
    ls
        List all worktrees

    help
    --help
    -h
        Show this help message

    version
    --version
    -v
        Show version information

    config [show|init]
        Manage configuration

CONFIGURATION:
    git-turnouts config show
        Display current configuration

    git-turnouts config init
        Create .config.yml from .config.yml.example

    Configuration file: .config.yml
    Example template:   .config.yml.example

    See .config.yml.example for all available options:
    - worktree.base_dir: Custom worktree location
    - worktree.copy_files: Files to copy to new worktrees
    - defaults.open_with: Default IDE (idea, code, iterm, warp, finder)
    - protection.protected_branches: Branches that cannot be deleted
    - remove.auto_prune: Auto-run git worktree prune after removing

EXAMPLES:
    # Create worktree from PR number
    git-turnouts add 7113

    # Create worktree and open in VS Code
    git-turnouts add feature-x --open code

    # Search for PR by title
    git-turnouts add "Add authentication"

    # Remove worktrees
    git-turnouts remove feature-x
    git-turnouts rm feat-1 feat-2 feat-3

    # List all worktrees
    git-turnouts list

For more information, visit:
https://github.com/yourusername/git-turnouts

EOF
}

show_version() {
  echo "Git Turnouts v${VERSION}"
}

# ============================================================================
# CONFIG COMMAND - Manage configuration
# ============================================================================

cmd_config() {
  local subcommand="${1:-show}"

  # Get the directory where git-turnouts is installed
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local config_file="$script_dir/.config.yml"
  local example_file="$script_dir/.config.yml.example"

  case "$subcommand" in
    show)
      echo "üìã Git Turnouts Configuration"
      echo ""
      echo "Configuration file: $config_file"
      [ -f "$config_file" ] && echo "                    (‚úì exists)" || echo "                    (not found - using defaults)"
      echo ""
      echo "Example file: $example_file"
      [ -f "$example_file" ] && echo "              (‚úì available)" || echo "              (not found)"
      echo ""
      echo "Current effective configuration:"
      echo ""

      # Show worktree configuration
      echo "  worktree:"
      local current_project=$(get_project_name)
      echo "    current project: $current_project"

      # Show global base_dir
      local global_base=$(get_config 'worktree.global.base_dir' '')
      if [ -n "$global_base" ]; then
        echo "    global.base_dir: $global_base"
        echo "                     (project name added automatically)"
      else
        echo "    global.base_dir: (not configured)"
      fi

      # Show project-specific base_dir
      local project_base=$(get_config "worktree.projects.${current_project}.base_dir" '')
      if [ -n "$project_base" ]; then
        echo "    projects.$current_project.base_dir: $project_base"
        echo "                                         (OVERRIDES global)"
      fi

      # Show what will actually be used
      local effective_base=$(get_base_worktree_dir)
      echo "    ‚Üí effective path: $effective_base/$current_project/[branch]"

      # Show all configured projects
      if [ -n "$CONFIG_WORKTREE_PROJECTS" ]; then
        echo ""
        echo "    configured projects:"
        for entry in $CONFIG_WORKTREE_PROJECTS; do
          local proj_name="${entry%%:*}"
          local proj_path="${entry#*:}"
          if [ "$proj_name" = "$current_project" ]; then
            echo "      - $proj_name: $proj_path (ACTIVE)"
          else
            echo "      - $proj_name: $proj_path"
          fi
        done
      fi

      # Show copy_files
      echo ""
      if [ -n "$CONFIG_COPY_FILES" ]; then
        echo "    copy_files:"
        for file in $CONFIG_COPY_FILES; do
          echo "      - $file"
        done
      else
        echo "    copy_files: (none)"
      fi

      # Show defaults
      echo ""
      echo "  defaults:"
      echo "    open_with: $(get_config 'defaults.open_with' 'idea')"

      # Show protection
      echo ""
      echo "  protection:"
      if [ -n "$CONFIG_PROTECTED_BRANCHES" ]; then
        echo "    protected_branches:"
        for branch in $CONFIG_PROTECTED_BRANCHES; do
          echo "      - $branch"
        done
      fi

      # Show remove settings
      echo ""
      echo "  remove:"
      echo "    auto_prune: $(get_config 'remove.auto_prune' 'true')"
      ;;
    init)
      # Create config file from example
      if [ ! -f "$example_file" ]; then
        echo "‚ùå Error: Example file not found: $example_file"
        echo "   Please ensure git-turnouts is properly installed"
        exit 1
      fi

      if [ -f "$config_file" ]; then
        echo "‚ö†Ô∏è  Config file already exists: $config_file"
        echo "   Remove it first or edit manually"
        exit 1
      fi

      cp "$example_file" "$config_file"
      echo "‚úÖ Created configuration file: $config_file"
      echo "   Edit this file to customize git-turnouts behavior"
      echo ""
      echo "   vim $config_file"
      ;;
    *)
      echo "Usage: git-turnouts config [show|init]"
      echo ""
      echo "Commands:"
      echo "  show    Show current configuration (default)"
      echo "  init    Create .config.yml from .config.yml.example"
      echo ""
      echo "Examples:"
      echo "  git-turnouts config show"
      echo "  git-turnouts config init"
      ;;
  esac
}

# ============================================================================
# MAIN DISPATCHER
# ============================================================================

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "‚ùå Error: Not a git repository"
  exit 1
fi

# Load configuration
load_configuration

# Parse command
COMMAND="${1:-help}"
shift || true

case "$COMMAND" in
  add)
    cmd_add "$@"
    ;;
  remove|rm)
    cmd_remove "$@"
    ;;
  list|ls)
    cmd_list "$@"
    ;;
  config)
    cmd_config "$@"
    ;;
  help|--help|-h)
    show_help
    ;;
  version|--version|-v)
    show_version
    ;;
  *)
    echo "‚ùå Error: Unknown command '$COMMAND'"
    echo ""
    echo "Run 'git-turnouts help' for usage information"
    exit 1
    ;;
esac
