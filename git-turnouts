#!/bin/bash

# Git Turnouts - Your Git branch switching yard
# Manage Git worktrees with intelligent GitHub Pull Request integration

set -e

VERSION="1.0.0"

# ============================================================================
# SHARED HELPER FUNCTIONS
# ============================================================================

# Function to get PR branch by title (exact or partial match)
get_pr_branch_by_title() {
  local search_term="$1"
  local exact_match="$2"

  if [ "$exact_match" = "true" ]; then
    # Exact match - PR title must exactly match the search term
    gh pr list --json number,title,headRefName | \
      jq -r --arg term "$search_term" '.[] | select(.title == $term) | .headRefName' | \
      head -n1
  else
    # Partial match - PR title must contain the search term
    gh pr list --json number,title,headRefName | \
      jq -r --arg term "$search_term" '.[] | select(.title | contains($term)) | .headRefName' | \
      head -n1
  fi
}

# Function to get PR details by PR number
get_pr_details_by_number() {
  local pr_number="$1"

  # Get PR details including state and merge information
  gh pr view "$pr_number" --json headRefName,state,mergedAt,baseRefName 2>/dev/null
}

# Function to get PR branch by PR number
get_pr_branch_by_number() {
  local pr_number="$1"

  # Get PR details by number
  gh pr view "$pr_number" --json headRefName 2>/dev/null | \
    jq -r '.headRefName' 2>/dev/null
}

# Function to check if a string is a PR number (all digits)
is_pr_number() {
  local input="$1"
  [[ "$input" =~ ^[0-9]+$ ]]
}

# Function to check if a string is quoted and strip quotes
check_and_strip_quotes() {
  local input="$1"
  # Check if string starts with " or ' and ends with the same quote
  if [[ "$input" =~ ^\"(.*)\"$ ]] || [[ "$input" =~ ^\'(.*)\'$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0  # Was quoted
  else
    echo "$input"
    return 1  # Was not quoted
  fi
}

# Get the main worktree path
get_main_worktree() {
  git worktree list | head -n1 | awk '{print $1}'
}

# Get project name from main repository
get_project_name() {
  local main_worktree=$(get_main_worktree)
  basename "$main_worktree"
}

# Get base worktree directory
# Returns the base directory where worktrees should be created
# The project name will be automatically added as a subdirectory
get_base_worktree_dir() {
  local project_name=$(get_project_name)

  # Use hierarchical lookup: project-specific ‚Üí global ‚Üí auto-detect
  local base_dir=$(get_config "worktree.base_dir" "" "$project_name")

  if [ -n "$base_dir" ]; then
    echo "$base_dir"
  else
    # Fallback to automatic detection (current behavior)
    local main_worktree=$(get_main_worktree)
    echo "$(dirname "$main_worktree")/worktree"
  fi
}

# ============================================================================
# CONFIGURATION SYSTEM
# ============================================================================

# Configuration variables (bash 3.2 compatible - no associative arrays)
# All configuration sections now support both global and project-specific settings
# Format: "project1:value1 project2:value2"

# Worktree configuration
CONFIG_WORKTREE_GLOBAL_BASE_DIR=""       # Global base directory (project name added automatically)
CONFIG_WORKTREE_PROJECTS=""              # Space-separated: "project1:path1 project2:path2"
CONFIG_WORKTREE_GLOBAL_COPY_FILES=""     # Space-separated list of global copy files
CONFIG_WORKTREE_PROJECTS_COPY_FILES=""   # Space-separated: "project1:file1,file2 project2:file3"

# Defaults configuration
CONFIG_DEFAULTS_GLOBAL_OPEN_WITH="idea"  # Hardcoded default
CONFIG_DEFAULTS_PROJECTS=""              # Space-separated: "project1:code project2:idea"

# Protection configuration
CONFIG_PROTECTION_GLOBAL_BRANCHES="main master"  # Hardcoded defaults (always protected)
CONFIG_PROTECTION_PROJECTS=""            # Space-separated: "project1:dev,staging project2:prod"

# Remove configuration
CONFIG_REMOVE_GLOBAL_AUTO_PRUNE="true"   # Hardcoded default
CONFIG_REMOVE_PROJECTS=""                # Space-separated: "project1:false project2:true"

# Parse simple YAML configuration (bash 3.2 compatible)
# Supports hierarchical structure: section.global.key and section.projects[].key
# All sections support both global and project-specific settings
parse_yaml_config() {
  local config_file="$1"
  local section=""              # Level 1: worktree, defaults, protection, remove
  local subsection=""           # Level 2: global, projects
  local in_project_item=false   # Are we inside a project list item?
  local in_list=false           # Are we inside a list (copy_files, protected_branches)?
  local list_type=""            # What type of list (copy_files, protected_branches)

  # Temporary variables for building project entries
  local current_project_name=""
  local current_project_data=""     # For base_dir, open_with, auto_prune
  local current_project_list=""     # For copy_files, protected_branches

  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// /}" ]] && continue

    # Level 1: Section headers (e.g., "worktree:", "defaults:")
    if [[ "$line" =~ ^([a-z_]+):([[:space:]]*|[[:space:]]+.*)$ ]]; then
      # Save any pending project data before switching sections
      save_project_data

      section="${BASH_REMATCH[1]}"
      subsection=""
      in_list=false
      in_project_item=false
      continue
    fi

    # Level 2: Subsection headers (e.g., "  global:", "  projects:")
    if [[ "$line" =~ ^[[:space:]]{2}([a-z_]+):[[:space:]]*(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Save any pending project data before switching subsections
      if [ "$key" != "$subsection" ]; then
        save_project_data
      fi

      subsection="$key"
      in_list=false
      in_project_item=false

      # Handle direct key-value pairs at level 2 (if value is present)
      if [ -n "$value" ]; then
        # Expand tilde in paths
        if [[ "$value" == ~* ]]; then
          value="${value/#\~/$HOME}"
        fi
        # These are legacy format, no longer used but kept for compatibility
      fi
      continue
    fi

    # Level 3: Keys under global or list items under projects
    if [[ "$line" =~ ^[[:space:]]{4}([a-z_-]+):[[:space:]]*(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Expand tilde in paths
      if [[ "$value" == ~* ]]; then
        value="${value/#\~/$HOME}"
      fi

      if [ "$subsection" = "global" ]; then
        # Handle global settings
        if [ -z "$value" ]; then
          # It's a list header (e.g., "    copy_files:" or "    protected_branches:")
          in_list=true
          list_type="$key"
        else
          # It's a direct key-value pair
          case "${section}.global.${key}" in
            "worktree.global.base_dir")
              CONFIG_WORKTREE_GLOBAL_BASE_DIR="$value"
              ;;
            "defaults.global.open_with")
              CONFIG_DEFAULTS_GLOBAL_OPEN_WITH="$value"
              ;;
            "remove.global.auto_prune")
              CONFIG_REMOVE_GLOBAL_AUTO_PRUNE="$value"
              ;;
          esac
        fi
      fi
      continue
    fi

    # Level 3: List items under projects (e.g., "    - name: my-app")
    if [[ "$line" =~ ^[[:space:]]{4}-[[:space:]]*(.*)$ ]]; then
      local rest="${BASH_REMATCH[1]}"

      if [ "$subsection" = "projects" ]; then
        # Save previous project before starting a new one
        save_project_data

        # Start new project item
        in_project_item=true
        current_project_name=""
        current_project_data=""
        current_project_list=""
        in_list=false

        # Check if name: is on the same line as dash
        if [[ "$rest" =~ ^name:[[:space:]]*(.+)$ ]]; then
          current_project_name="${BASH_REMATCH[1]}"
        fi
      fi
      # Note: Global list items are handled at level 4 (6 spaces)
      continue
    fi

    # Level 4: List items under global lists OR properties within project items
    # Check for list items first (e.g., "      - .editorconfig")
    if [[ "$line" =~ ^[[:space:]]{6}-[[:space:]]*(.*)$ ]]; then
      local item="${BASH_REMATCH[1]}"

      if [ "$in_list" = true ] && [ "$subsection" = "global" ]; then
        # List item under global (e.g., copy_files or protected_branches)
        case "${section}.global.${list_type}" in
          "worktree.global.copy_files")
            CONFIG_WORKTREE_GLOBAL_COPY_FILES="$CONFIG_WORKTREE_GLOBAL_COPY_FILES $item"
            ;;
          "protection.global.protected_branches")
            CONFIG_PROTECTION_GLOBAL_BRANCHES="$CONFIG_PROTECTION_GLOBAL_BRANCHES $item"
            ;;
        esac
      fi
      continue
    fi

    # Level 4: Properties within project items (e.g., "      name: value")
    if [[ "$line" =~ ^[[:space:]]{6}([a-z_]+):[[:space:]]*(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"

      # Expand tilde in paths
      if [[ "$value" == ~* ]]; then
        value="${value/#\~/$HOME}"
      fi

      if [ "$in_project_item" = true ]; then
        if [ "$key" = "name" ]; then
          current_project_name="$value"
        elif [ -z "$value" ]; then
          # It's a list header under project (e.g., "      copy_files:")
          in_list=true
          list_type="$key"
        else
          # It's a direct value under project
          current_project_data="$value"
        fi
      fi
      continue
    fi

    # Level 5: List items under project properties (e.g., "        - .editorconfig")
    if [[ "$line" =~ ^[[:space:]]{8}-[[:space:]]*(.*)$ ]]; then
      local item="${BASH_REMATCH[1]}"

      if [ "$in_project_item" = true ] && [ "$in_list" = true ]; then
        # Add to project's list (comma-separated)
        if [ -z "$current_project_list" ]; then
          current_project_list="$item"
        else
          current_project_list="$current_project_list,$item"
        fi
      fi
      continue
    fi
  done < "$config_file"

  # Save any remaining project data
  save_project_data

  # Trim leading spaces from global lists
  CONFIG_WORKTREE_GLOBAL_COPY_FILES="${CONFIG_WORKTREE_GLOBAL_COPY_FILES## }"
  CONFIG_PROTECTION_GLOBAL_BRANCHES="${CONFIG_PROTECTION_GLOBAL_BRANCHES## }"
  CONFIG_WORKTREE_PROJECTS="${CONFIG_WORKTREE_PROJECTS## }"
  CONFIG_DEFAULTS_PROJECTS="${CONFIG_DEFAULTS_PROJECTS## }"
  CONFIG_PROTECTION_PROJECTS="${CONFIG_PROTECTION_PROJECTS## }"
  CONFIG_REMOVE_PROJECTS="${CONFIG_REMOVE_PROJECTS## }"
  CONFIG_WORKTREE_PROJECTS_COPY_FILES="${CONFIG_WORKTREE_PROJECTS_COPY_FILES## }"
}

# Helper function to save accumulated project data
save_project_data() {
  if [ "$in_project_item" = true ] && [ -n "$current_project_name" ]; then
    # Determine which configuration variable to update based on section
    case "$section" in
      worktree)
        if [ -n "$current_project_data" ]; then
          # Save base_dir
          CONFIG_WORKTREE_PROJECTS="$CONFIG_WORKTREE_PROJECTS ${current_project_name}:${current_project_data}"
        fi
        if [ -n "$current_project_list" ]; then
          # Save copy_files list
          CONFIG_WORKTREE_PROJECTS_COPY_FILES="$CONFIG_WORKTREE_PROJECTS_COPY_FILES ${current_project_name}:${current_project_list}"
        fi
        ;;
      defaults)
        if [ -n "$current_project_data" ]; then
          CONFIG_DEFAULTS_PROJECTS="$CONFIG_DEFAULTS_PROJECTS ${current_project_name}:${current_project_data}"
        fi
        ;;
      protection)
        if [ -n "$current_project_list" ]; then
          CONFIG_PROTECTION_PROJECTS="$CONFIG_PROTECTION_PROJECTS ${current_project_name}:${current_project_list}"
        fi
        ;;
      remove)
        if [ -n "$current_project_data" ]; then
          CONFIG_REMOVE_PROJECTS="$CONFIG_REMOVE_PROJECTS ${current_project_name}:${current_project_data}"
        fi
        ;;
    esac

    # Reset for next project
    current_project_name=""
    current_project_data=""
    current_project_list=""
    in_list=false
  fi
  in_project_item=false
}

# Validate configuration values (bash 3.2 compatible)
validate_configuration() {
  # Validate defaults.global.open_with
  if [ -n "$CONFIG_DEFAULTS_GLOBAL_OPEN_WITH" ]; then
    case "$CONFIG_DEFAULTS_GLOBAL_OPEN_WITH" in
      idea|code|iterm|warp|finder)
        ;;  # Valid
      *)
        echo "‚ö†Ô∏è  Warning: Invalid defaults.global.open_with value '$CONFIG_DEFAULTS_GLOBAL_OPEN_WITH' in config"
        echo "   Valid options: idea, code, iterm, warp, finder"
        echo "   Falling back to default: idea"
        CONFIG_DEFAULTS_GLOBAL_OPEN_WITH="idea"
        ;;
    esac
  fi

  # Validate project-specific open_with values
  for entry in $CONFIG_DEFAULTS_PROJECTS; do
    local proj_name="${entry%%:*}"
    local open_with="${entry#*:}"
    case "$open_with" in
      idea|code|iterm|warp|finder)
        ;;  # Valid
      *)
        echo "‚ö†Ô∏è  Warning: Invalid open_with value '$open_with' for project '$proj_name'"
        echo "   Valid options: idea, code, iterm, warp, finder"
        echo "   This project will use global setting"
        # Remove invalid entry
        CONFIG_DEFAULTS_PROJECTS="${CONFIG_DEFAULTS_PROJECTS//${entry}/}"
        ;;
    esac
  done

  # Validate worktree.global.base_dir exists or can be created
  if [ -n "$CONFIG_WORKTREE_GLOBAL_BASE_DIR" ]; then
    if [ ! -d "$CONFIG_WORKTREE_GLOBAL_BASE_DIR" ]; then
      local parent_dir=$(dirname "$CONFIG_WORKTREE_GLOBAL_BASE_DIR")
      if [ ! -d "$parent_dir" ]; then
        echo "‚ö†Ô∏è  Warning: Configured worktree.global.base_dir parent does not exist: $parent_dir"
        echo "   Falling back to automatic detection"
        CONFIG_WORKTREE_GLOBAL_BASE_DIR=""
      fi
    fi
  fi

  # Validate and normalize remove.global.auto_prune to true/false
  case "$CONFIG_REMOVE_GLOBAL_AUTO_PRUNE" in
    true|false)
      ;;  # Already normalized
    yes|1)
      CONFIG_REMOVE_GLOBAL_AUTO_PRUNE="true"
      ;;
    no|0)
      CONFIG_REMOVE_GLOBAL_AUTO_PRUNE="false"
      ;;
    *)
      echo "‚ö†Ô∏è  Warning: Invalid remove.global.auto_prune value '$CONFIG_REMOVE_GLOBAL_AUTO_PRUNE' in config"
      echo "   Valid options: true, false, yes, no, 1, 0"
      echo "   Falling back to default: true"
      CONFIG_REMOVE_GLOBAL_AUTO_PRUNE="true"
      ;;
  esac

  # Validate and normalize project-specific auto_prune values
  local validated_remove_projects=""
  for entry in $CONFIG_REMOVE_PROJECTS; do
    local proj_name="${entry%%:*}"
    local auto_prune="${entry#*:}"
    case "$auto_prune" in
      true|false)
        validated_remove_projects="$validated_remove_projects ${entry}"
        ;;
      yes|1)
        validated_remove_projects="$validated_remove_projects ${proj_name}:true"
        ;;
      no|0)
        validated_remove_projects="$validated_remove_projects ${proj_name}:false"
        ;;
      *)
        echo "‚ö†Ô∏è  Warning: Invalid auto_prune value '$auto_prune' for project '$proj_name'"
        echo "   Valid options: true, false, yes, no, 1, 0"
        echo "   This project will use global setting"
        ;;
    esac
  done
  CONFIG_REMOVE_PROJECTS="${validated_remove_projects## }"
}

# Load configuration from file (bash 3.2 compatible)
load_configuration() {
  # Get the directory where git-turnouts is installed
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local config_file="$script_dir/.config.yml"

  # Defaults are already set in variable declarations above
  # Only load and parse if config file exists
  if [ -f "$config_file" ]; then
    if [ -r "$config_file" ]; then
      parse_yaml_config "$config_file" 2>/dev/null || {
        echo "‚ö†Ô∏è  Warning: Error parsing config file: $config_file"
        echo "   Continuing with defaults..."
      }
      # Validate configuration after loading
      validate_configuration
    else
      echo "‚ö†Ô∏è  Warning: Cannot read config file: $config_file"
      echo "   Continuing with defaults..."
    fi
  fi
}

# Get configuration value with fallback (bash 3.2 compatible)
# Supports hierarchical lookup: project-specific ‚Üí global ‚Üí hardcoded default
# Usage: get_config "key" "hardcoded_default" ["project_name"]
get_config() {
  local key="$1"
  local default="${2:-}"
  local project="${3:-}"  # Optional: specific project, otherwise auto-detect

  # Auto-detect project if not provided
  if [ -z "$project" ]; then
    project=$(get_project_name 2>/dev/null || echo "")
  fi

  case "$key" in
    # Worktree base_dir: project-specific ‚Üí global ‚Üí hardcoded default
    worktree.base_dir)
      # 1. Check project-specific setting
      if [ -n "$project" ]; then
        for entry in $CONFIG_WORKTREE_PROJECTS; do
          local proj_name="${entry%%:*}"
          local proj_path="${entry#*:}"
          if [ "$proj_name" = "$project" ]; then
            echo "$proj_path"
            return
          fi
        done
      fi

      # 2. Check global setting
      if [ -n "$CONFIG_WORKTREE_GLOBAL_BASE_DIR" ]; then
        echo "$CONFIG_WORKTREE_GLOBAL_BASE_DIR"
        return
      fi

      # 3. Use hardcoded default
      echo "$default"
      ;;

    # Worktree copy_files: project-specific ‚Üí global ‚Üí hardcoded default
    worktree.copy_files)
      # 1. Check project-specific setting
      if [ -n "$project" ]; then
        for entry in $CONFIG_WORKTREE_PROJECTS_COPY_FILES; do
          local proj_name="${entry%%:*}"
          local proj_files="${entry#*:}"
          if [ "$proj_name" = "$project" ]; then
            # Convert comma-separated to space-separated
            echo "${proj_files//,/ }"
            return
          fi
        done
      fi

      # 2. Use global setting
      if [ -n "$CONFIG_WORKTREE_GLOBAL_COPY_FILES" ]; then
        echo "$CONFIG_WORKTREE_GLOBAL_COPY_FILES"
        return
      fi

      # 3. Use hardcoded default (empty)
      echo "$default"
      ;;

    # Defaults open_with: project-specific ‚Üí global ‚Üí hardcoded default
    defaults.open_with)
      # 1. Check project-specific setting
      if [ -n "$project" ]; then
        for entry in $CONFIG_DEFAULTS_PROJECTS; do
          local proj_name="${entry%%:*}"
          local proj_value="${entry#*:}"
          if [ "$proj_name" = "$project" ]; then
            echo "$proj_value"
            return
          fi
        done
      fi

      # 2. Check global setting
      if [ -n "$CONFIG_DEFAULTS_GLOBAL_OPEN_WITH" ]; then
        echo "$CONFIG_DEFAULTS_GLOBAL_OPEN_WITH"
        return
      fi

      # 3. Use hardcoded default
      echo "$default"
      ;;

    # Protection protected_branches: project-specific ‚Üí global ‚Üí hardcoded default
    protection.protected_branches)
      # 1. Check project-specific setting
      if [ -n "$project" ]; then
        for entry in $CONFIG_PROTECTION_PROJECTS; do
          local proj_name="${entry%%:*}"
          local proj_branches="${entry#*:}"
          if [ "$proj_name" = "$project" ]; then
            # Convert comma-separated to space-separated, always include main/master
            echo "main master ${proj_branches//,/ }"
            return
          fi
        done
      fi

      # 2. Use global setting (always include main/master)
      if [ -n "$CONFIG_PROTECTION_GLOBAL_BRANCHES" ]; then
        echo "$CONFIG_PROTECTION_GLOBAL_BRANCHES"
        return
      fi

      # 3. Use hardcoded default (main master are always protected)
      echo "$default"
      ;;

    # Remove auto_prune: project-specific ‚Üí global ‚Üí hardcoded default
    remove.auto_prune)
      # 1. Check project-specific setting
      if [ -n "$project" ]; then
        for entry in $CONFIG_REMOVE_PROJECTS; do
          local proj_name="${entry%%:*}"
          local proj_value="${entry#*:}"
          if [ "$proj_name" = "$project" ]; then
            echo "$proj_value"
            return
          fi
        done
      fi

      # 2. Check global setting
      if [ -n "$CONFIG_REMOVE_GLOBAL_AUTO_PRUNE" ]; then
        echo "$CONFIG_REMOVE_GLOBAL_AUTO_PRUNE"
        return
      fi

      # 3. Use hardcoded default
      echo "$default"
      ;;

    # Legacy support for old key formats
    worktree.global.base_dir)
      echo "${CONFIG_WORKTREE_GLOBAL_BASE_DIR:-$default}"
      ;;

    defaults.global.open_with)
      echo "${CONFIG_DEFAULTS_GLOBAL_OPEN_WITH:-$default}"
      ;;

    remove.global.auto_prune)
      echo "${CONFIG_REMOVE_GLOBAL_AUTO_PRUNE:-$default}"
      ;;

    *)
      echo "$default"
      ;;
  esac
}

# Copy configured files from main worktree to new worktree (bash 3.2 compatible)
copy_configured_files() {
  local source_dir="$1"    # Main worktree path
  local target_dir="$2"    # New worktree path

  # Get copy_files configuration (project-specific ‚Üí global ‚Üí empty)
  local copy_files=$(get_config "worktree.copy_files" "")

  # Check if there are files to copy
  if [ -z "$copy_files" ]; then
    return 0
  fi

  echo "üìÑ Copying configured files..."
  local copied=0
  local skipped=0

  # Iterate over space-separated list
  for file in $copy_files; do
    local source_file="$source_dir/$file"
    local target_file="$target_dir/$file"

    if [ -f "$source_file" ]; then
      # Create target directory if needed
      local target_dir_parent=$(dirname "$target_file")
      mkdir -p "$target_dir_parent"

      # Copy file
      if cp "$source_file" "$target_file" 2>/dev/null; then
        echo "   ‚úì Copied: $file"
        copied=$((copied + 1))
      else
        echo "   ‚ö† Failed to copy: $file"
        skipped=$((skipped + 1))
      fi
    else
      echo "   ‚ö† Not found: $file (skipped)"
      skipped=$((skipped + 1))
    fi
  done

  if [ $copied -gt 0 ]; then
    echo "   Copied $copied file(s)"
  fi
  if [ $skipped -gt 0 ]; then
    echo "   Skipped $skipped file(s)"
  fi
}

# ============================================================================
# ADD COMMAND - Create new worktrees
# ============================================================================

cmd_add() {
  # Load default from config
  local OPEN_APP=$(get_config "defaults.open_with" "idea")

  # Function to show usage for add command
  show_add_usage() {
    echo "Usage: git-turnouts add <name> [branch-name] [--open <app>]"
    echo ""
    echo "Arguments:"
    echo "  <name>: Folder name for the worktree, PR number, or PR title"
    echo "          If numeric (e.g., 7113), treats as PR number and checkouts that PR"
    echo "          If no branch-name provided, also used as branch name"
    echo "          Will check if this matches any PR title and use that PR's branch"
    echo "  [branch-name]: Optional, specific branch name (defaults to <name>)"
    echo "                 Will check if this matches any PR title and use that PR's branch"
    echo "  --open <app>: Optional, specify where to open (default: idea)"
    echo "                Available apps: idea, code, iterm, warp, finder"
    echo ""
    echo "PR Detection:"
    echo "  - PR Number: If <name> is numeric (e.g., 7113), directly checkouts that PR"
    echo "    Uses PR number as folder name and PR's branch for checkout"
    echo "  - When only <name> is provided: checks if any PR title contains <name>"
    echo "    If found, uses PR's branch name for both folder and branch"
    echo "  - When both arguments provided: checks if any PR title contains [branch-name]"
    echo "    If found, uses PR's branch but keeps specified folder name"
    echo "  - Use quotes for exact title matching: \"exact title\" vs partial matching"
    echo "  - If no matching PR is found, uses standard branch resolution"
    echo ""
    echo "Examples:"
    echo "  git-turnouts add 7113                         # Checkouts PR #7113"
    echo "  git-turnouts add feature-x                    # Creates feature-x worktree"
    echo "  git-turnouts add JIRA-123                     # Checks for PR with JIRA-123"
    echo "  git-turnouts add \"Exact PR Title\"             # Exact title match"
    echo "  git-turnouts add folder-name branch-name      # Different names"
    echo "  git-turnouts add feature-x --open code        # Opens in VS Code"
  }

  if [ -z "$1" ]; then
    show_add_usage
    exit 1
  fi

  # Parse arguments
  local FOLDER_NAME=""
  local BRANCH=""
  local PARSING_OPEN=false
  local EXTRA_ARGS=0

  for arg in "$@"; do
    if [ "$PARSING_OPEN" = true ]; then
      OPEN_APP="$arg"
      PARSING_OPEN=false
    elif [ "$arg" = "--open" ] || [ "$arg" = "-o" ]; then
      PARSING_OPEN=true
    elif [ -z "$FOLDER_NAME" ]; then
      FOLDER_NAME="$arg"
    elif [ -z "$BRANCH" ]; then
      BRANCH="$arg"
    else
      EXTRA_ARGS=$((EXTRA_ARGS + 1))
    fi
  done

  # Validate argument count
  if [ $EXTRA_ARGS -gt 0 ]; then
    echo "‚ùå Error: Too many arguments provided"
    echo "Expected: git-turnouts add <name> [branch-name] [--open <app>]"
    echo ""
    echo "You provided more than 2 positional arguments."
    echo "If your argument contains spaces, please enclose it in quotes."
    echo "Example: git-turnouts add \"My PR Title with spaces\""
    echo ""
    show_add_usage
    exit 1
  fi

  # If no branch specified, use folder name
  if [ -z "$BRANCH" ]; then
    BRANCH="$FOLDER_NAME"
  fi

  # Check if we should use a PR branch
  local PR_BRANCH=""
  local ORIGINAL_FOLDER_NAME="$FOLDER_NAME"

  if [ -z "$BRANCH" ] || [ "$BRANCH" = "$FOLDER_NAME" ]; then
    # Case 1: Only <name> argument passed

    # First check if it's a PR number
    if is_pr_number "$FOLDER_NAME"; then
      echo "üî¢ Detected PR number: #$FOLDER_NAME"
      echo "üîç Fetching PR #$FOLDER_NAME details..."

      # Get full PR details including state
      PR_DETAILS=$(get_pr_details_by_number "$FOLDER_NAME")
      if [ -z "$PR_DETAILS" ]; then
        echo "‚ùå Error: PR #$FOLDER_NAME not found or not accessible"
        exit 1
      fi

      PR_STATE=$(echo "$PR_DETAILS" | jq -r '.state')
      PR_BRANCH=$(echo "$PR_DETAILS" | jq -r '.headRefName')
      BASE_BRANCH=$(echo "$PR_DETAILS" | jq -r '.baseRefName')

      if [ "$PR_STATE" = "MERGED" ]; then
        echo "‚ö†Ô∏è  PR #$FOLDER_NAME has been merged into $BASE_BRANCH"
        echo ""
        echo "The PR branch '$PR_BRANCH' may have been deleted from remote."
        echo ""
        echo "Options:"
        echo "  1. Checkout the merge commit from $BASE_BRANCH"
        echo "  2. If the branch still exists remotely, you can try: git fetch origin $PR_BRANCH"
        echo "  3. Create a new feature branch from $BASE_BRANCH"
        exit 1
      elif [ "$PR_STATE" = "CLOSED" ]; then
        echo "‚ö†Ô∏è  PR #$FOLDER_NAME is closed (not merged)"
        echo "Branch: $PR_BRANCH"
        echo ""
        echo "Note: The branch may still exist. Proceeding to attempt checkout..."
        BRANCH="$PR_BRANCH"
      else
        echo "üìã Found PR #$FOLDER_NAME (state: $PR_STATE), using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      fi
    else
      # Not a PR number, check for PR title matching
      set +e  # Temporarily disable exit on error
      SEARCH_TERM=$(check_and_strip_quotes "$FOLDER_NAME")
      WAS_QUOTED=$?
      set -e  # Re-enable exit on error

      if [ $WAS_QUOTED -eq 0 ]; then
        echo "üîç Checking for PR with exact title '$SEARCH_TERM'..."
        PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "true")
        if [ -n "$PR_BRANCH" ]; then
          echo "üìã Found PR with exact title '$SEARCH_TERM', using branch: $PR_BRANCH"
          BRANCH="$PR_BRANCH"
          FOLDER_NAME="${PR_BRANCH//\//-}"
        else
          echo "‚ÑπÔ∏è  No PR found with exact title '$SEARCH_TERM', using standard branch resolution"
          FOLDER_NAME="$SEARCH_TERM"
        fi
      else
        echo "üîç Checking for PR with title containing '$SEARCH_TERM'..."
        PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "false")
        if [ -n "$PR_BRANCH" ]; then
          echo "üìã Found PR with title containing '$SEARCH_TERM', using branch: $PR_BRANCH"
          BRANCH="$PR_BRANCH"
          FOLDER_NAME="${PR_BRANCH//\//-}"
        else
          echo "‚ÑπÔ∏è  No PR found with title containing '$SEARCH_TERM', using standard branch resolution"
          FOLDER_NAME="$SEARCH_TERM"
        fi
      fi
    fi
  else
    # Case 2: Both <name> and [branch-name] passed
    set +e  # Temporarily disable exit on error
    SEARCH_TERM=$(check_and_strip_quotes "$BRANCH")
    WAS_QUOTED=$?
    set -e  # Re-enable exit on error

    if [ $WAS_QUOTED -eq 0 ]; then
      echo "üîç Checking for PR with exact title '$SEARCH_TERM'..."
      PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "true")
      if [ -n "$PR_BRANCH" ]; then
        echo "üìã Found PR with exact title '$SEARCH_TERM', using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      else
        echo "‚ÑπÔ∏è  No PR found with exact title '$SEARCH_TERM', using standard branch resolution"
        BRANCH="$SEARCH_TERM"
      fi
    else
      echo "üîç Checking for PR with title containing '$SEARCH_TERM'..."
      PR_BRANCH=$(get_pr_branch_by_title "$SEARCH_TERM" "false")
      if [ -n "$PR_BRANCH" ]; then
        echo "üìã Found PR with title containing '$SEARCH_TERM', using branch: $PR_BRANCH"
        BRANCH="$PR_BRANCH"
      else
        echo "‚ÑπÔ∏è  No PR found with title containing '$SEARCH_TERM', using standard branch resolution"
      fi
    fi
  fi

  # Validate open app option
  case "$OPEN_APP" in
    idea|code|iterm|warp|finder)
      ;;
    *)
      echo "‚ùå Error: Invalid app '$OPEN_APP'"
      echo "Valid options: idea, code, iterm, warp, finder"
      exit 1
      ;;
  esac

  # Get the main worktree path
  local MAIN_WORKTREE=$(get_main_worktree)
  local PROJECT_NAME=$(get_project_name)
  local BASE_WORKTREE_DIR=$(get_base_worktree_dir)

  mkdir -p "$BASE_WORKTREE_DIR"

  # Get absolute path of base dir
  local BASE_WORKTREE_DIR_ABS=$(realpath "$BASE_WORKTREE_DIR")

  # Create project-specific directory (always added for organization)
  local PROJECT_WORKTREE_DIR="$BASE_WORKTREE_DIR_ABS/$PROJECT_NAME"
  mkdir -p "$PROJECT_WORKTREE_DIR"

  # Append folder name
  local TARGET_DIR="$PROJECT_WORKTREE_DIR/$FOLDER_NAME"

  echo "üì¶ Project: $PROJECT_NAME"
  echo "üìÅ Worktree folder: $TARGET_DIR"
  echo "üåø Branch: $BRANCH"

  # Check if target directory already exists
  if [ -d "$TARGET_DIR" ]; then
    echo "‚ùå Error: Directory already exists: $TARGET_DIR"
    echo "Please choose a different folder name or remove the existing directory first."
    exit 1
  fi

  # Check if branch is already checked out in another worktree
  local EXISTING_WORKTREE=$(git worktree list --porcelain | grep -B2 "branch refs/heads/$BRANCH" | grep "^worktree" | cut -d' ' -f2)
  if [ -n "$EXISTING_WORKTREE" ] && [ "$EXISTING_WORKTREE" != "$TARGET_DIR" ]; then
    echo "‚ùå Error: Branch '$BRANCH' is already checked out in worktree at: $EXISTING_WORKTREE"
    echo ""
    echo "Options:"
    echo "  1. Use a different folder name to create a new branch"
    echo "  2. Navigate to the existing worktree: cd $EXISTING_WORKTREE"
    echo "  3. Remove the existing worktree: git-turnouts remove $BRANCH"
    exit 1
  fi

  # Check if this was a PR number checkout
  local IS_PR_CHECKOUT=false
  if is_pr_number "$ORIGINAL_FOLDER_NAME" && [ -z "$2" ]; then
    IS_PR_CHECKOUT=true
  fi

  # Create worktree based on branch state
  if [ "$IS_PR_CHECKOUT" = true ]; then
    # For PR checkouts, ensure the PR branch is properly fetched
    echo "üîÑ Fetching PR #$ORIGINAL_FOLDER_NAME branch..."

    git fetch origin "$BRANCH" || {
      echo "‚ùå Error: Failed to fetch PR #$ORIGINAL_FOLDER_NAME branch"
      exit 1
    }

    echo "üì¶ Creating worktree for PR #$ORIGINAL_FOLDER_NAME (branch: $BRANCH)"
    git worktree add -B "$BRANCH" "$TARGET_DIR" "origin/$BRANCH"
  elif git show-ref --verify --quiet refs/remotes/origin/$BRANCH; then
    # Remote branch exists, create local branch tracking it
    echo "üöÄ Creating new local branch '$BRANCH' from 'origin/$BRANCH'"
    git worktree add -B "$BRANCH" "$TARGET_DIR" "origin/$BRANCH"
  else
    # No remote branch, create new branch from HEAD
    echo "üÜï Creating new branch '$BRANCH' from HEAD"
    git worktree add -b "$BRANCH" "$TARGET_DIR" HEAD
  fi

  echo "‚úÖ Worktree created at: $TARGET_DIR (branch: $BRANCH)"

  # Copy configured files
  copy_configured_files "$MAIN_WORKTREE" "$TARGET_DIR"

  # Open in specified application
  case "$OPEN_APP" in
    idea)
      echo "üß† Opening in IntelliJ IDEA..."
      idea "$TARGET_DIR"
      ;;
    code)
      echo "üìù Opening in VS Code..."
      code "$TARGET_DIR"
      ;;
    iterm)
      echo "üñ•Ô∏è  Opening in iTerm..."
      osascript -e "tell application \"iTerm\"
        create window with default profile
        tell current session of current window
          write text \"cd \\\"$TARGET_DIR\\\"\"
        end tell
      end tell"
      ;;
    warp)
      echo "üöÄ Opening in Warp..."
      open -a Warp "$TARGET_DIR"
      ;;
    finder)
      echo "üìÇ Opening in Finder..."
      open "$TARGET_DIR"
      ;;
  esac
}

# ============================================================================
# REMOVE COMMAND - Remove worktrees
# ============================================================================

cmd_remove() {
  show_remove_usage() {
    echo "Usage: git-turnouts remove <worktree-name> [worktree-name2 ...]"
    echo "       git-turnouts rm <worktree-name> [worktree-name2 ...]"
    echo ""
    echo "Remove one or more worktrees by their branch name."
    echo ""
    echo "Examples:"
    echo "  git-turnouts remove feature-branch"
    echo "  git-turnouts rm test1 test2 feature-branch"
  }

  if [ $# -eq 0 ]; then
    show_remove_usage
    exit 1
  fi

  # Function to remove a single worktree
  remove_worktree() {
    local WORKTREE_NAME="$1"

    # Get all worktrees and find the one matching the given name
    local WORKTREE_PATH=""
    local BRANCH_NAME=""
    while IFS= read -r line; do
      # Extract the branch name from brackets
      if [[ "$line" =~ \[([^\]]+)\] ]]; then
        local BRANCH="${BASH_REMATCH[1]}"
        if [ "$BRANCH" = "$WORKTREE_NAME" ]; then
          # Extract the path (first whitespace-separated token)
          WORKTREE_PATH=$(echo "$line" | awk '{print $1}')
          BRANCH_NAME="$BRANCH"
          break
        fi
      fi
    done < <(git worktree list)

    if [ -z "$WORKTREE_PATH" ]; then
      echo "‚ö†Ô∏è  Warning: No worktree found with name '$WORKTREE_NAME' - skipping"
      return 1
    fi

    echo "Found worktree '$WORKTREE_NAME' at: $WORKTREE_PATH"

    if [ ! -d "$WORKTREE_PATH" ]; then
      echo "‚ö†Ô∏è  Warning: Worktree path '$WORKTREE_PATH' does not exist - skipping"
      return 1
    fi

    echo "Removing worktree '$WORKTREE_NAME' at: $WORKTREE_PATH"

    # Check if this is a protected branch to avoid deleting it
    local DEFAULT_BRANCH
    DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

    # Get protected branches (project-specific ‚Üí global ‚Üí default: main master)
    local protected_branches=$(get_config "protection.protected_branches" "main master")

    # Check against configured protected branches (space-separated list)
    local SKIP_BRANCH_DELETE=false
    for protected in $protected_branches $DEFAULT_BRANCH; do
      if [ "$BRANCH_NAME" = "$protected" ]; then
        echo "‚ö†Ô∏è  Warning: Cannot delete protected branch '$BRANCH_NAME' - removing worktree only"
        SKIP_BRANCH_DELETE=true
        break
      fi
    done

    if git worktree remove --force "$WORKTREE_PATH"; then
      echo "‚úÖ Worktree '$WORKTREE_NAME' removed successfully"

      # Now remove the branch if it's safe to do so
      if [ "$SKIP_BRANCH_DELETE" = false ]; then
        echo "üóëÔ∏è  Deleting branch '$BRANCH_NAME'..."
        if git branch -D "$BRANCH_NAME" 2>/dev/null; then
          echo "‚úÖ Branch '$BRANCH_NAME' deleted successfully"
        else
          echo "‚ö†Ô∏è  Warning: Could not delete branch '$BRANCH_NAME' (it may not exist locally or be already deleted)"
        fi
      fi

      return 0
    else
      echo "‚ùå Failed to remove worktree '$WORKTREE_NAME'"
      return 1
    fi
  }

  # Track success/failure
  local TOTAL=0
  local REMOVED=0
  local FAILED=0

  # Show appropriate message based on number of worktrees
  if [ $# -eq 1 ]; then
    echo "üóëÔ∏è  Removing worktree '$1'..."
  else
    echo "üóëÔ∏è  Starting bulk worktree removal..."
  fi
  echo

  # Process each worktree name
  for WORKTREE_NAME in "$@"; do
    TOTAL=$((TOTAL + 1))

    # Show progress counter only for multiple worktrees
    if [ $# -gt 1 ]; then
      echo "[$TOTAL/$#] Processing '$WORKTREE_NAME'..."
    fi

    if remove_worktree "$WORKTREE_NAME"; then
      REMOVED=$((REMOVED + 1))
    else
      FAILED=$((FAILED + 1))
    fi

    echo
  done

  # Prune once at the end (if configured)
  local auto_prune=$(get_config "remove.auto_prune" "true")
  if [ "$auto_prune" = "true" ]; then
    echo "Pruning stale worktree references..."
    git worktree prune
  else
    echo "‚ÑπÔ∏è  Skipping prune (disabled in config)"
  fi

  # Summary
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "üìä Summary:"
  echo "   Total: $TOTAL"
  echo "   ‚úÖ Removed: $REMOVED"
  if [ $FAILED -gt 0 ]; then
    echo "   ‚ö†Ô∏è  Failed/Skipped: $FAILED"
  fi
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

  # Show updated list
  echo
  echo "üìã Updated list of worktrees:"
  git worktree list

  # Exit with error if all removals failed
  if [ $REMOVED -eq 0 ] && [ $TOTAL -gt 0 ]; then
    exit 1
  fi
}

# ============================================================================
# LIST COMMAND - List all worktrees
# ============================================================================

cmd_list() {
  echo "üìã Git Worktrees:"
  git worktree list
}

# ============================================================================
# HELP & VERSION
# ============================================================================

show_help() {
  cat << EOF
Git Turnouts v${VERSION} - Your Git branch switching yard

Manage Git worktrees with intelligent GitHub Pull Request integration.
Just like railroad turnouts route trains between tracks, Git Turnouts helps
you seamlessly switch between multiple branches and work contexts.

USAGE:
    git-turnouts <command> [options]

COMMANDS:
    add <name> [branch] [--open <app>]
        Create a new worktree with optional PR integration

    remove <name> [name2 ...]
    rm <name> [name2 ...]
        Remove one or more worktrees

    list
    ls
        List all worktrees

    help
    --help
    -h
        Show this help message

    version
    --version
    -v
        Show version information

    config [show|init]
        Manage configuration

CONFIGURATION:
    git-turnouts config show
        Display current configuration

    git-turnouts config init
        Create .config.yml from .config.yml.example

    Configuration file: .config.yml
    Example template:   .config.yml.example

    See .config.yml.example for all available options:
    - worktree.base_dir: Custom worktree location
    - worktree.copy_files: Files to copy to new worktrees
    - defaults.open_with: Default IDE (idea, code, iterm, warp, finder)
    - protection.protected_branches: Branches that cannot be deleted
    - remove.auto_prune: Auto-run git worktree prune after removing

EXAMPLES:
    # Create worktree from PR number
    git-turnouts add 7113

    # Create worktree and open in VS Code
    git-turnouts add feature-x --open code

    # Search for PR by title
    git-turnouts add "Add authentication"

    # Remove worktrees
    git-turnouts remove feature-x
    git-turnouts rm feat-1 feat-2 feat-3

    # List all worktrees
    git-turnouts list

For more information, visit:
https://github.com/yourusername/git-turnouts

EOF
}

show_version() {
  echo "Git Turnouts v${VERSION}"
}

# ============================================================================
# CONFIG COMMAND - Manage configuration
# ============================================================================

cmd_config() {
  local subcommand="${1:-show}"

  # Get the directory where git-turnouts is installed
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local config_file="$script_dir/.config.yml"
  local example_file="$script_dir/.config.yml.example"

  case "$subcommand" in
    show)
      echo "üìã Git Turnouts Configuration"
      echo ""
      echo "Configuration file: $config_file"
      [ -f "$config_file" ] && echo "                    (‚úì exists)" || echo "                    (not found - using defaults)"
      echo ""
      echo "Example file: $example_file"
      [ -f "$example_file" ] && echo "              (‚úì available)" || echo "              (not found)"
      echo ""
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo "Current Effective Configuration"
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""

      local current_project=$(get_project_name)
      echo "üì¶ Current Project: $current_project"
      echo ""

      # ========== WORKTREE CONFIGURATION ==========
      echo "üóÇÔ∏è  Worktree Configuration"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

      # Base directory
      echo "  Base Directory:"
      if [ -n "$CONFIG_WORKTREE_GLOBAL_BASE_DIR" ]; then
        echo "    Global:  $CONFIG_WORKTREE_GLOBAL_BASE_DIR"
      else
        echo "    Global:  (not configured, using auto-detect)"
      fi

      # Check if current project has override
      local has_project_base=false
      for entry in $CONFIG_WORKTREE_PROJECTS; do
        local proj_name="${entry%%:*}"
        local proj_path="${entry#*:}"
        if [ "$proj_name" = "$current_project" ]; then
          echo "    Project: $proj_path ‚≠ê ACTIVE OVERRIDE"
          has_project_base=true
          break
        fi
      done

      if [ "$has_project_base" = false ] && [ -n "$CONFIG_WORKTREE_PROJECTS" ]; then
        echo "    Project: (using global setting)"
      fi

      local effective_base=$(get_base_worktree_dir)
      echo "    ‚Üí Effective: $effective_base/$current_project/[branch]"

      # Copy files
      echo ""
      echo "  Files to Copy:"
      local effective_copy_files=$(get_config "worktree.copy_files" "")
      if [ -n "$CONFIG_WORKTREE_GLOBAL_COPY_FILES" ]; then
        echo "    Global:"
        for file in $CONFIG_WORKTREE_GLOBAL_COPY_FILES; do
          echo "      - $file"
        done
      else
        echo "    Global:  (none)"
      fi

      # Check if current project has override
      local has_project_copy=false
      for entry in $CONFIG_WORKTREE_PROJECTS_COPY_FILES; do
        local proj_name="${entry%%:*}"
        if [ "$proj_name" = "$current_project" ]; then
          echo "    Project: ‚≠ê ACTIVE OVERRIDE"
          local proj_files="${entry#*:}"
          for file in ${proj_files//,/ }; do
            echo "      - $file"
          done
          has_project_copy=true
          break
        fi
      done

      if [ "$has_project_copy" = false ] && [ -n "$CONFIG_WORKTREE_PROJECTS_COPY_FILES" ]; then
        echo "    Project: (using global setting)"
      fi

      if [ -n "$effective_copy_files" ]; then
        echo "    ‚Üí Effective: $effective_copy_files"
      else
        echo "    ‚Üí Effective: (no files to copy)"
      fi

      # All configured projects
      if [ -n "$CONFIG_WORKTREE_PROJECTS" ] || [ -n "$CONFIG_WORKTREE_PROJECTS_COPY_FILES" ]; then
        echo ""
        echo "  All Configured Projects:"
        local all_projects=""
        for entry in $CONFIG_WORKTREE_PROJECTS; do
          local proj_name="${entry%%:*}"
          if [[ ! " $all_projects " =~ " $proj_name " ]]; then
            all_projects="$all_projects $proj_name"
          fi
        done
        for entry in $CONFIG_WORKTREE_PROJECTS_COPY_FILES; do
          local proj_name="${entry%%:*}"
          if [[ ! " $all_projects " =~ " $proj_name " ]]; then
            all_projects="$all_projects $proj_name"
          fi
        done
        for proj in $all_projects; do
          if [ "$proj" = "$current_project" ]; then
            echo "    - $proj ‚≠ê ACTIVE"
          else
            echo "    - $proj"
          fi
        done
      fi

      # ========== DEFAULTS CONFIGURATION ==========
      echo ""
      echo "‚öôÔ∏è  Default Behavior"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      echo "  Open With (IDE):"
      echo "    Global:  $CONFIG_DEFAULTS_GLOBAL_OPEN_WITH"

      # Check if current project has override
      local has_project_open=false
      for entry in $CONFIG_DEFAULTS_PROJECTS; do
        local proj_name="${entry%%:*}"
        local proj_value="${entry#*:}"
        if [ "$proj_name" = "$current_project" ]; then
          echo "    Project: $proj_value ‚≠ê ACTIVE OVERRIDE"
          has_project_open=true
          break
        fi
      done

      if [ "$has_project_open" = false ] && [ -n "$CONFIG_DEFAULTS_PROJECTS" ]; then
        echo "    Project: (using global setting)"
      fi

      local effective_open=$(get_config "defaults.open_with" "idea")
      echo "    ‚Üí Effective: $effective_open"

      # ========== PROTECTION CONFIGURATION ==========
      echo ""
      echo "üõ°Ô∏è  Branch Protection"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      echo "  Protected Branches:"
      if [ -n "$CONFIG_PROTECTION_GLOBAL_BRANCHES" ]; then
        echo "    Global:"
        for branch in $CONFIG_PROTECTION_GLOBAL_BRANCHES; do
          echo "      - $branch"
        done
      else
        echo "    Global:  main, master (hardcoded defaults)"
      fi

      # Check if current project has override
      local has_project_protect=false
      for entry in $CONFIG_PROTECTION_PROJECTS; do
        local proj_name="${entry%%:*}"
        if [ "$proj_name" = "$current_project" ]; then
          echo "    Project: ‚≠ê ACTIVE OVERRIDE"
          local proj_branches="${entry#*:}"
          for branch in ${proj_branches//,/ }; do
            echo "      - $branch"
          done
          has_project_protect=true
          break
        fi
      done

      if [ "$has_project_protect" = false ] && [ -n "$CONFIG_PROTECTION_PROJECTS" ]; then
        echo "    Project: (using global setting)"
      fi

      local effective_protect=$(get_config "protection.protected_branches" "main master")
      echo "    ‚Üí Effective: $effective_protect"
      echo "    Note: main and master are ALWAYS protected"

      # ========== REMOVE CONFIGURATION ==========
      echo ""
      echo "üóëÔ∏è  Removal Behavior"
      echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
      echo "  Auto Prune:"
      echo "    Global:  $CONFIG_REMOVE_GLOBAL_AUTO_PRUNE"

      # Check if current project has override
      local has_project_prune=false
      for entry in $CONFIG_REMOVE_PROJECTS; do
        local proj_name="${entry%%:*}"
        local proj_value="${entry#*:}"
        if [ "$proj_name" = "$current_project" ]; then
          echo "    Project: $proj_value ‚≠ê ACTIVE OVERRIDE"
          has_project_prune=true
          break
        fi
      done

      if [ "$has_project_prune" = false ] && [ -n "$CONFIG_REMOVE_PROJECTS" ]; then
        echo "    Project: (using global setting)"
      fi

      local effective_prune=$(get_config "remove.auto_prune" "true")
      echo "    ‚Üí Effective: $effective_prune"

      echo ""
      echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
      echo ""
      echo "üí° Hierarchy: Project-specific ‚Üí Global ‚Üí Hardcoded defaults"
      echo "   Edit: $config_file"
      ;;
    init)
      # Create config file from example
      if [ ! -f "$example_file" ]; then
        echo "‚ùå Error: Example file not found: $example_file"
        echo "   Please ensure git-turnouts is properly installed"
        exit 1
      fi

      if [ -f "$config_file" ]; then
        echo "‚ö†Ô∏è  Config file already exists: $config_file"
        echo "   Remove it first or edit manually"
        exit 1
      fi

      cp "$example_file" "$config_file"
      echo "‚úÖ Created configuration file: $config_file"
      echo "   Edit this file to customize git-turnouts behavior"
      echo ""
      echo "   vim $config_file"
      ;;
    *)
      echo "Usage: git-turnouts config [show|init]"
      echo ""
      echo "Commands:"
      echo "  show    Show current configuration (default)"
      echo "  init    Create .config.yml from .config.yml.example"
      echo ""
      echo "Examples:"
      echo "  git-turnouts config show"
      echo "  git-turnouts config init"
      ;;
  esac
}

# ============================================================================
# MAIN DISPATCHER
# ============================================================================

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "‚ùå Error: Not a git repository"
  exit 1
fi

# Load configuration
load_configuration

# Parse command
COMMAND="${1:-help}"
shift || true

case "$COMMAND" in
  add)
    cmd_add "$@"
    ;;
  remove|rm)
    cmd_remove "$@"
    ;;
  list|ls)
    cmd_list "$@"
    ;;
  config)
    cmd_config "$@"
    ;;
  help|--help|-h)
    show_help
    ;;
  version|--version|-v)
    show_version
    ;;
  *)
    echo "‚ùå Error: Unknown command '$COMMAND'"
    echo ""
    echo "Run 'git-turnouts help' for usage information"
    exit 1
    ;;
esac
